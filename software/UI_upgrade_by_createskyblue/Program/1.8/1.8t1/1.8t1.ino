/*License: http://creativecommons.org/licenses/by-sa/3.0/
   采用CC3.0协议共享此程序
   您可以自由地
  共享 — 在任何媒介以任何形式复制、发行本作品
  演绎 — 修改、转换或以本作品为基础进行创作
  在任何用途下，甚至商业目的。
  本许可协议为“自由文化作品（Free Cultural Works）”所接受。
  只要你遵守许可协议条款，许可人就无法收回你的这些权利。

  Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)
  This is a human-readable summary of (and not a substitute for) the license. Disclaimer.
  You are free to:
  Share — copy and redistribute the material in any medium or format
  Adapt — remix, transform, and build upon the material
  for any purpose, even commercially.
  This license is acceptable for Free Cultural Works.
  The licensor cannot revoke these freedoms as long as you follow the license terms.
*/
// SolderingStation2
//
// ATmega328-controlled Soldering Station for Hakko T12 Tips.
// 此v1.8t1版本功能简介
// This 1.8t1 version of the code implements:
// - 烙铁头温度实时监测
// - Temperature measurement of the tip
// - PID温度控制
// - Direct or PID control of the heater
// - 可以通过编码器进行控制温度
// - Temperature control via rotary encoder
// - 短按编码器进入短时升温模式
// - Boost mode by short pressing rotary encoder switch
// - 长按编码器进入主菜单
// - Setup menu by long pressing rotary encoder switch
// - 手柄震动检测（需要手柄含有震动传感器）
// - Handle movement detection (by checking ball switch)
// - 手柄连接检测（通过判断烙铁头温度是否能够被读取来实现）
// - Iron unconnected detection (by idenfying invalid temperature readings)
// - 定时器设定 - 随眠，关机时间
// - Time driven sleep/power off mode if iron is unused (movement detection)
// - 可以测量主控芯片电压以及温度
// - Measurement of input voltage, Vcc and ATmega's internal temperature
// - 在OLED上实现信息显示
// - Information display on OLED
// - 支持无源蜂鸣器
// - Buzzer
// - 允许设置不同烙铁头的温度校准值
// - Calibrating and managing different soldering tips
// - 设置被保存在EEPROM，掉电不丢失
// - Storing user settings into the EEPROM
// - 允许热插拔烙铁头，并弹出烙铁头配置选择菜单
// - Tip change detection
// - 芯片过热以及低电压报警
// - Chip overheating and low voltage alarm
// - 更好的实时温度条以及实时功率条
// - Better real-time temperature bar and real-time power bar
// - 拥有过渡动画
// - Have transition animation
// - 内置屏幕保护程序
// - Built in screen saver
// - 屏幕翻转设置
// - Screen flip settings
// - 内置英文、中文、日文语言包
// - Built in English, Chinese and Japanese language pack
// - 开机密码设置
// - System Password

// Power supply should be in the range of 16V/2A to 24V/3A and well
// stabilized.
//
// For calibration you need a soldering iron tips thermometer. For best results
// wait at least three minutes after switching on the soldering station before
// you start the calibration process.
//
// Controller:  ATmega328p
// Core:        Barebones ATmega (https://github.com/carlosefr/atmega)
// Clockspeed:  16 MHz external
//
// 2019/2020 by Stefan Wagner with great support from John Glavinos
// 2020-8 UI upgrade by LHW-createskyblue 、lihaoyun6
// Project Page: https://easyeda.com/wagiminator

//关于界面-项目页面二维码 ->为了加入欠压报警只能阉割掉关于页面的二维码
//const unsigned char QRCode[] PROGMEM = { 0x00, 0x00, 0x3e, 0x0e, 0x7c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x0e, 0x7c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x0e, 0x7c, 0x0c, 0x00, 0x00, 0x1f, 0xfe, 0x3f, 0xc1, 0x8c, 0x0c, 0x7f, 0xf8, 0x1f, 0xfe, 0x3f, 0xc1, 0x8c, 0x0c, 0x7f, 0xf8, 0x18, 0x06, 0x30, 0x01, 0xf3, 0x8c, 0x60, 0x18, 0x18, 0x06, 0x30, 0x01, 0xf3, 0x8c, 0x60, 0x18, 0x18, 0x06, 0x30, 0x01, 0xf3, 0x8c, 0x60, 0x18, 0x18, 0x06, 0x3e, 0x0f, 0xf0, 0x0c, 0x60, 0x18, 0x18, 0x06, 0x3e, 0x0f, 0xf0, 0x0c, 0x60, 0x18, 0x18, 0x06, 0x3f, 0xc1, 0xf0, 0x0c, 0x60, 0x18, 0x18, 0x06, 0x3f, 0xc1, 0xf0, 0x0c, 0x60, 0x18, 0x18, 0x06, 0x3f, 0xc1, 0xf0, 0x0c, 0x60, 0x18, 0x1f, 0xfe, 0x3e, 0x30, 0x70, 0x0c, 0x7f, 0xf8, 0x1f, 0xfe, 0x3e, 0x30, 0x70, 0x0c, 0x7f, 0xf8, 0x00, 0x00, 0x31, 0xce, 0x73, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x31, 0xce, 0x73, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x31, 0xce, 0x73, 0x8c, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x01, 0x83, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x01, 0x83, 0x8f, 0xff, 0xff, 0x00, 0xc0, 0x01, 0xc1, 0x8c, 0x00, 0x7f, 0x1f, 0x00, 0xc0, 0x01, 0xc1, 0x8c, 0x00, 0x7f, 0x1f, 0x00, 0xc0, 0x01, 0xc1, 0x8c, 0x00, 0x7f, 0x1f, 0x07, 0xc7, 0xcf, 0xce, 0x7f, 0x8c, 0x1f, 0xf8, 0x07, 0xc7, 0xcf, 0xce, 0x7f, 0x8c, 0x1f, 0xf8, 0x07, 0xc7, 0xcf, 0xce, 0x7f, 0x8c, 0x1f, 0xf8, 0xf8, 0x00, 0x3e, 0x3e, 0x03, 0xf0, 0x7f, 0x00, 0xf8, 0x00, 0x3e, 0x3e, 0x03, 0xf0, 0x7f, 0x00, 0xe0, 0xc7, 0xcf, 0xfe, 0x03, 0x80, 0x1f, 0xe7, 0xe0, 0xc7, 0xcf, 0xfe, 0x03, 0x80, 0x1f, 0xe7, 0xe0, 0xc7, 0xcf, 0xfe, 0x03, 0x80, 0x1f, 0xe7, 0x18, 0xc0, 0x31, 0xfe, 0x0c, 0x0c, 0x1c, 0xe0, 0x18, 0xc0, 0x31, 0xfe, 0x0c, 0x0c, 0x1c, 0xe0, 0xe7, 0x39, 0xf1, 0xf0, 0x03, 0xfc, 0x7c, 0xf8, 0xe7, 0x39, 0xf1, 0xf0, 0x03, 0xfc, 0x7c, 0xf8, 0xe7, 0x39, 0xf1, 0xf0, 0x03, 0xfc, 0x7c, 0xf8, 0x1f, 0x00, 0x31, 0xcf, 0xf3, 0x8c, 0x03, 0x00, 0x1f, 0x00, 0x31, 0xcf, 0xf3, 0x8c, 0x03, 0x00, 0xe0, 0x3f, 0xff, 0xc1, 0x83, 0x8f, 0x9c, 0xe7, 0xe0, 0x3f, 0xff, 0xc1, 0x83, 0x8f, 0x9c, 0xe7, 0xe0, 0x3f, 0xff, 0xc1, 0x83, 0x8f, 0x9c, 0xe7, 0x18, 0x00, 0x30, 0x0e, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x30, 0x0e, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x30, 0x0e, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x3e, 0x7c, 0x0f, 0xe0, 0x00, 0xff, 0xff, 0xf0, 0x3e, 0x7c, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x31, 0xce, 0x0c, 0x0c, 0x63, 0xe0, 0x00, 0x00, 0x31, 0xce, 0x0c, 0x0c, 0x63, 0xe0, 0x00, 0x00, 0x31, 0xce, 0x0c, 0x0c, 0x63, 0xe0, 0x1f, 0xfe, 0x30, 0x01, 0x83, 0x8f, 0xe0, 0xff, 0x1f, 0xfe, 0x30, 0x01, 0x83, 0x8f, 0xe0, 0xff, 0x18, 0x06, 0x31, 0xf1, 0x8f, 0x80, 0x03, 0xe7, 0x18, 0x06, 0x31, 0xf1, 0x8f, 0x80, 0x03, 0xe7, 0x18, 0x06, 0x31, 0xf1, 0x8f, 0x80, 0x03, 0xe7, 0x18, 0x06, 0x3f, 0xff, 0x83, 0x83, 0xe3, 0x1f, 0x18, 0x06, 0x3f, 0xff, 0x83, 0x83, 0xe3, 0x1f, 0x18, 0x06, 0x31, 0xfe, 0x73, 0x8f, 0x80, 0xf8, 0x18, 0x06, 0x31, 0xfe, 0x73, 0x8f, 0x80, 0xf8, 0x18, 0x06, 0x31, 0xfe, 0x73, 0x8f, 0x80, 0xf8, 0x1f, 0xfe, 0x31, 0xfe, 0x00, 0x0c, 0x60, 0xe7, 0x1f, 0xfe, 0x31, 0xfe, 0x00, 0x0c, 0x60, 0xe7, 0x00, 0x00, 0x31, 0xfe, 0x0c, 0x0f, 0x9f, 0xe0, 0x00, 0x00, 0x31, 0xfe, 0x0c, 0x0f, 0x9f, 0xe0, 0x00, 0x00, 0x31, 0xfe, 0x0c, 0x0f, 0x9f, 0xe0 };
const unsigned char QRCode[] PROGMEM = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x03, 0x86, 0x70, 0x80, 0x03, 0x80, 0x03, 0x86, 0x70, 0x80, 0x03, 0x9f, 0xf3, 0xe1, 0x30, 0x9f, 0xf3, 0x9f, 0xf3, 0xe1, 0x30, 0x9f, 0xf3, 0x98, 0x33, 0x01, 0xcc, 0x98, 0x33, 0x98, 0x33, 0x01, 0xcc, 0x98, 0x33, 0x98, 0x33, 0x87, 0xc0, 0x98, 0x33, 0x98, 0x33, 0xe1, 0xc0, 0x98, 0x33, 0x98, 0x33, 0xe1, 0xc0, 0x98, 0x33, 0x9f, 0xf3, 0x98, 0xc0, 0x9f, 0xf3, 0x9f, 0xf3, 0x98, 0xc0, 0x9f, 0xf3, 0x80, 0x03, 0x66, 0xcc, 0x80, 0x03, 0x80, 0x03, 0x66, 0xcc, 0x80, 0x03, 0xff, 0xff, 0x01, 0x0c, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x1f, 0xff, 0x81, 0x00, 0x61, 0x30, 0x1f, 0x3f, 0x87, 0x3c, 0xe6, 0xfc, 0x87, 0x33, 0x87, 0x3c, 0xe6, 0xfc, 0x87, 0xf3, 0xf8, 0x03, 0x9e, 0x0f, 0x1f, 0x03, 0xf8, 0x03, 0x9e, 0x0f, 0x1f, 0x03, 0xe1, 0x3c, 0xfe, 0x0c, 0x07, 0xcf, 0xe1, 0x3c, 0xfe, 0x0c, 0x07, 0xcf, 0x99, 0x03, 0x3e, 0x30, 0x86, 0xc3, 0xe6, 0xcf, 0x38, 0x0f, 0x9e, 0xf3, 0xe6, 0xcf, 0x38, 0x0f, 0x9e, 0xf3, 0x9e, 0x03, 0x27, 0xcc, 0x81, 0x03, 0x9e, 0x03, 0x27, 0xcc, 0x81, 0x03, 0xe0, 0xff, 0xe1, 0x0c, 0xe6, 0xcf, 0xe0, 0xff, 0xe1, 0x0c, 0xe6, 0xcf, 0x98, 0x03, 0x06, 0x00, 0x00, 0xff, 0x98, 0x03, 0x06, 0x00, 0x00, 0xff, 0xff, 0xff, 0x1e, 0xf0, 0xf8, 0x03, 0x80, 0x03, 0x66, 0x30, 0x99, 0xc3, 0x80, 0x03, 0x66, 0x30, 0x99, 0xc3, 0x9f, 0xf3, 0x01, 0x0c, 0xf8, 0xff, 0x9f, 0xf3, 0x01, 0x0c, 0xf8, 0xff, 0x98, 0x33, 0x39, 0x3c, 0x01, 0xcf, 0x98, 0x33, 0x39, 0x3c, 0x01, 0xcf, 0x98, 0x33, 0xff, 0x0c, 0x79, 0x3f, 0x98, 0x33, 0x3e, 0xcc, 0xe0, 0xf3, 0x98, 0x33, 0x3e, 0xcc, 0xe0, 0xf3, 0x9f, 0xf3, 0x3e, 0x00, 0x98, 0xcf, 0x9f, 0xf3, 0x3e, 0x00, 0x98, 0xcf, 0x80, 0x03, 0x3e, 0x30, 0xe7, 0xc3, 0x80, 0x03, 0x3e, 0x30, 0xe7, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
//ICO
//width:16,height:16
const unsigned char Tag[] PROGMEM = { 0x00, 0x00, 0x3b, 0xec, 0x7b, 0xee, 0x63, 0xe6, 0x63, 0xe6, 0x63, 0xe6, 0x63, 0xe6, 0x63, 0xe6, 0x63, 0xe6, 0x63, 0x66, 0x62, 0x26, 0x60, 0x06, 0x60, 0x06, 0x7f, 0xfe, 0x3f, 0xfc, 0x00, 0x00 };
const unsigned char Chip[] PROGMEM = { 0x14, 0xa0, 0x3f, 0xf0, 0x7f, 0xf8, 0xe0, 0x1c, 0x6e, 0x18, 0xec, 0x1c, 0x68, 0x18, 0x60, 0x18, 0xe0, 0x1c, 0x60, 0x58, 0xe0, 0x1c, 0x7f, 0xf8, 0x3f, 0xf0, 0x14, 0xa0 };
//const unsigned char HeatPipe[] PROGMEM  = { 0x00, 0x00, 0x09, 0x90, 0x11, 0x88, 0x21, 0x84, 0x11, 0x88, 0x09, 0x90, 0x11, 0x88, 0x21, 0x84, 0x11, 0x88, 0x09, 0x90, 0x11, 0x88, 0x21, 0x84, 0x11, 0x88, 0x09, 0x90, 0x01, 0x80, 0x00, 0x00 };
const unsigned char Lightning[] PROGMEM = { 0x0f, 0xe0, 0x1f, 0xc0, 0x1f, 0xc0, 0x3f, 0x80, 0x3f, 0xf8, 0x7f, 0xf0, 0x7f, 0xe0, 0x07, 0xc0, 0x07, 0x80, 0x0f, 0x00, 0x0e, 0x00, 0x1c, 0x00, 0x18, 0x00, 0x10, 0x00 };
//const unsigned char Thermometer[] PROGMEM = { 0x01, 0x80, 0x02, 0x40, 0x03, 0x40, 0x02, 0x40, 0x03, 0x40, 0x02, 0x40, 0x03, 0x40, 0x02, 0x40, 0x03, 0x40, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x03, 0xc0 };
const unsigned char Pointer[] PROGMEM = { 0x20, 0x20, 0x70, 0xf8 };
//状态提示
//width:14,height:14 图标库

const unsigned char c1[] PROGMEM = { 0x03, 0x00, 0x07, 0x80, 0x0f, 0xc0, 0x0c, 0xc0, 0x1c, 0xe0, 0x1c, 0xe0, 0x3c, 0xf0, 0x3c, 0xf0, 0x7f, 0xf8, 0x7f, 0xf8, 0xfc, 0xfc, 0xfc, 0xfc, 0xff, 0xfc, 0x7f, 0xf8 };
const unsigned char c2[] PROGMEM = { 0x7f, 0xf8, 0xff, 0xfc, 0xc0, 0x0c, 0xc3, 0x0c, 0xcb, 0x4c, 0xdb, 0x6c, 0xdb, 0x6c, 0xd8, 0x6c, 0xdc, 0xec, 0xcf, 0xcc, 0xc7, 0x8c, 0xc0, 0x0c, 0xff, 0xfc, 0x7f, 0xf8 };
const unsigned char c3[] PROGMEM = { 0x00, 0x00, 0x06, 0x00, 0x0c, 0x00, 0x18, 0xf8, 0x38, 0xf0, 0x30, 0x30, 0x70, 0x60, 0x70, 0x78, 0x78, 0xf8, 0x78, 0x00, 0x3c, 0x02, 0x3f, 0x0c, 0x1f, 0xf8, 0x0f, 0xf0, 0x03, 0xc0, 0x00, 0x00 };
const unsigned char c5[] PROGMEM = { 0x7f, 0xf0, 0xff, 0xe0, 0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x38, 0xc8, 0x70, 0xdc, 0xe4, 0xcf, 0xcc, 0xc7, 0x8c, 0xc3, 0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xff, 0xfc, 0x7f, 0xf8 };
const unsigned char c6[] PROGMEM = { 0x1e, 0x10, 0x33, 0x38, 0x2d, 0x7c, 0x25, 0x38, 0x2d, 0x38, 0x25, 0x38, 0x2d, 0x38, 0x6d, 0x80, 0xde, 0xc0, 0xbf, 0x40, 0xbf, 0x40, 0xde, 0xc0, 0x61, 0x80, 0x3f, 0x00 };
const unsigned char c7[] PROGMEM = { 0x1f, 0xe0, 0x3f, 0xf0, 0x70, 0x38, 0x60, 0x18, 0x60, 0x18, 0x60, 0x18, 0xff, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xf8, 0x7c, 0xf8, 0x7c, 0xfc, 0xfc, 0x7f, 0xf8 };
const unsigned char c_NO[] PROGMEM  = { 0x80, 0x04, 0x00, 0x00, 0x3f, 0xf0, 0x37, 0xb0, 0x23, 0x10, 0x30, 0x30, 0x38, 0x70, 0x38, 0x70, 0x30, 0x30, 0x23, 0x10, 0x37, 0xb0, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char *C_table[] = {c1, c2, c3, Lightning, c5, c6, c7};

//设置（陈星汉认为语言是一种低像素的表达方式,容易造成隔阂; 交互界面设计尽可能形象化）
// width: 14, height: 14
const unsigned char QRC[] PROGMEM = { 0x05, 0x80, 0x74, 0xb8, 0x57, 0xa8, 0x76, 0xb8, 0x05, 0x80, 0xf9, 0x7c, 0x46, 0x94, 0xaa, 0xa8, 0xf9, 0x7c, 0x06, 0x88, 0x74, 0xa8, 0x57, 0x8c, 0x75, 0x74, 0x06, 0x98 };
const unsigned char Set0[] PROGMEM = { 0x88, 0x24, 0x08, 0x20, 0x38, 0x30, 0x38, 0x30, 0x38, 0x30, 0x38, 0x30, 0x38, 0x30, 0x38, 0x30, 0x39, 0x30, 0x3b, 0xb0, 0x3f, 0xf0, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Set1[] PROGMEM = { 0xf8, 0x7c, 0xf3, 0x3c, 0xf4, 0xbc, 0xf6, 0xbc, 0xf4, 0xbc, 0xf6, 0xbc, 0xf4, 0xbc, 0xe4, 0x9c, 0xc8, 0x4c, 0xd0, 0x2c, 0xd0, 0x2c, 0xc8, 0x4c, 0xe7, 0x9c, 0xf0, 0x3c };
const unsigned char Set2[] PROGMEM = { 0x8f, 0xc4, 0x10, 0x20, 0x20, 0x10, 0x4c, 0xc8, 0x9f, 0xe4, 0x3d, 0xf0, 0x3d, 0xf0, 0x1d, 0xe0, 0x3e, 0xf0, 0x3f, 0x70, 0x9f, 0xe4, 0x8c, 0xc4, 0x00, 0x00, 0x30, 0x30 };
const unsigned char Set3[] PROGMEM = { 0xc3, 0xfc, 0x18, 0x00, 0x18, 0x00, 0xc3, 0xfc, 0xff, 0xfc, 0xff, 0x0c, 0x00, 0x60, 0x00, 0x60, 0xff, 0x0c, 0xff, 0xfc, 0xf0, 0xfc, 0x06, 0x00, 0x06, 0x00, 0xf0, 0xfc };
const unsigned char Set4[] PROGMEM = { 0x80, 0x04, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x08, 0x00, 0x10, 0x00, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Set4F[] PROGMEM = { 0x80, 0x04, 0x00, 0x00, 0x3f, 0xf0, 0x38, 0x30, 0x33, 0x10, 0x3f, 0x90, 0x38, 0x10, 0x33, 0x90, 0x27, 0x90, 0x26, 0x10, 0x30, 0x90, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Set4FF[] PROGMEM  = { 0x80, 0x04, 0x00, 0x00, 0x3f, 0xf0, 0x24, 0x30, 0x21, 0x90, 0x27, 0x90, 0x27, 0x30, 0x20, 0x70, 0x27, 0xf0, 0x23, 0x30, 0x30, 0x70, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Set5[] PROGMEM = { 0xfc, 0xfc, 0xf8, 0x7c, 0xe0, 0x1c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0x80, 0x04, 0x80, 0x04, 0xff, 0xfc, 0xf8, 0x7c, 0xfc, 0xfc };
const unsigned char Set5_1[] PROGMEM = { 0xfc, 0xf4, 0xf8, 0x60, 0xe0, 0x44, 0xc0, 0x8c, 0xc1, 0x1c, 0xc2, 0x2c, 0xc4, 0x4c, 0xc8, 0x8c, 0xd1, 0x0c, 0xa2, 0x04, 0xc4, 0x04, 0x8f, 0xfc, 0x18, 0x7c, 0xbc, 0xfc };
const unsigned char Set6[] PROGMEM = { 0xf8, 0x7c, 0xe0, 0x1c, 0xc0, 0x0c, 0xcf, 0xcc, 0xcf, 0xcc, 0xcf, 0xcc, 0xcf, 0xcc, 0xcf, 0xcc, 0xcf, 0xcc, 0xcf, 0xcc, 0xc8, 0x4c, 0xcf, 0xcc, 0xc0, 0x0c, 0xe0, 0x1c };
const unsigned char Set_LANG[] PROGMEM  = { 0xf0, 0x3c, 0xce, 0x4c, 0xbc, 0x34, 0xb8, 0x14, 0x18, 0x80, 0x10, 0x80, 0x42, 0x30, 0x60, 0x78, 0x60, 0xf8, 0x44, 0xc0, 0x80, 0x04, 0xb8, 0x84, 0xcf, 0xcc, 0xf0, 0x3c };
const unsigned char Set7[] PROGMEM = { 0x80, 0x0c, 0x00, 0x1c, 0x3f, 0xf4, 0x3f, 0xe0, 0x3f, 0xc4, 0x37, 0x8c, 0x23, 0x18, 0x30, 0x30, 0x38, 0x70, 0x3c, 0xf0, 0x3f, 0xf0, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Set11[] PROGMEM = { 0xf3, 0xfc, 0xe7, 0xfc, 0xce, 0x0c, 0x8e, 0x1c, 0x9f, 0x9c, 0x1f, 0x3c, 0x1f, 0x0c, 0x0e, 0x0c, 0x0f, 0xfc, 0x87, 0xf8, 0x81, 0xe4, 0xc0, 0x0c, 0xe0, 0x1c, 0xf8, 0x7c };
const unsigned char Set8[] PROGMEM = { 0x81, 0xdc, 0x55, 0x9c, 0x29, 0x04, 0x55, 0x00, 0x29, 0x90, 0x55, 0xd0, 0x03, 0xfc, 0xff, 0x00, 0x2e, 0x00, 0x26, 0x70, 0x02, 0x50, 0x82, 0x70, 0xe6, 0x00, 0xee, 0x04 };
const unsigned char Set9[] PROGMEM = { 0xf0, 0x3c, 0xce, 0x0c, 0xbf, 0x04, 0xb3, 0x04, 0x73, 0x00, 0x7f, 0x00, 0x7e, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x60, 0xbc, 0x64, 0xbe, 0x04, 0xcf, 0x0c, 0xf0, 0x3c };
const unsigned char Set10[] PROGMEM = { 0xf8, 0x7c, 0xf7, 0xbc, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0xbf, 0xf4, 0xab, 0x54, 0xab, 0x54, 0xab, 0x54, 0xab, 0x54, 0xab, 0x54, 0xab, 0x54, 0xbf, 0xf4, 0xc0, 0x0c };
const unsigned char Set13[] PROGMEM = { 0x80, 0x04, 0x00, 0x00, 0x3f, 0xf0, 0x3c, 0xf0, 0x34, 0xb0, 0x24, 0x90, 0x24, 0x90, 0x27, 0x90, 0x23, 0x10, 0x30, 0x30, 0x38, 0x70, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Set12[] PROGMEM = { 0x80, 0x04, 0x00, 0x00, 0x3f, 0xf0, 0x3c, 0xf0, 0x3c, 0xf0, 0x3c, 0xf0, 0x20, 0x10, 0x20, 0x10, 0x3c, 0xf0, 0x3c, 0xf0, 0x3c, 0xf0, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Set14[] PROGMEM = { 0xff, 0x7c, 0xfe, 0x7c, 0xfc, 0xec, 0xe8, 0xdc, 0xc8, 0x4c, 0x98, 0x4c, 0x88, 0x24, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0xe0, 0x1c };
const unsigned char Set15[] PROGMEM = { 0x15, 0x54, 0x3f, 0xfc, 0x15, 0x54, 0x3f, 0xfc, 0x15, 0x54, 0x3c, 0x04, 0x14, 0x04, 0x3c, 0xfc, 0x14, 0x54, 0x3c, 0xfc, 0x00, 0x54, 0x00, 0xa8, 0x00, 0x00, 0x00, 0x00 };
const unsigned char Set16[] PROGMEM = { 0x15, 0x54, 0x3f, 0xf8, 0x15, 0x50, 0x3f, 0xf0, 0x15, 0x50, 0x38, 0x70, 0x10, 0x20, 0x31, 0x04, 0x13, 0x8c, 0x22, 0xa8, 0x17, 0xfc, 0x2a, 0xa8, 0x00, 0x00, 0x00, 0x00 };
const unsigned char Set17[] PROGMEM = { 0x80, 0x00, 0xbf, 0xf8, 0x1f, 0xf8, 0xb0, 0x08, 0x18, 0x08, 0xb9, 0xe8, 0x19, 0xb8, 0xb8, 0x38, 0x18, 0x38, 0xb9, 0xb8, 0xb9, 0xf8, 0xb0, 0xf8, 0xbf, 0xf8, 0x80, 0x00 };
const unsigned char Set18[] PROGMEM = { 0x80, 0x00, 0xbf, 0xf8, 0x1f, 0xf8, 0xb0, 0x28, 0x1f, 0xf8, 0xb4, 0x08, 0x1f, 0xf8, 0xb1, 0x08, 0x1f, 0xf8, 0xb0, 0x48, 0xbf, 0xf8, 0xb2, 0x88, 0xbf, 0xf8, 0x80, 0x00 };
const unsigned char Lang_CN[] PROGMEM = { 0x80, 0x04, 0x00, 0x00, 0x3f, 0xf0, 0x3c, 0xf0, 0x3c, 0xf0, 0x20, 0x10, 0x24, 0x90, 0x24, 0x90, 0x20, 0x10, 0x3c, 0xf0, 0x3c, 0xf0, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Lang_EN[] PROGMEM = { 0x80, 0x04, 0x00, 0x00, 0x3f, 0xf0, 0x38, 0x70, 0x30, 0x30, 0x23, 0x10, 0x27, 0x90, 0x20, 0x10, 0x20, 0x10, 0x27, 0x90, 0x27, 0x90, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Lang_JP[] PROGMEM = { 0x80, 0x04, 0x00, 0x00, 0x3f, 0xf0, 0x3d, 0xf0, 0x20, 0x10, 0x3b, 0xf0, 0x3b, 0x70, 0x30, 0x30, 0x2b, 0x50, 0x2a, 0xd0, 0x31, 0xb0, 0x3f, 0xf0, 0x00, 0x00, 0x80, 0x04 };
const unsigned char Save[] PROGMEM = { 0x00, 0x04, 0x58, 0x08, 0x58, 0x08, 0x58, 0x08, 0x40, 0x08, 0x7f, 0xf8, 0x60, 0x18, 0x5f, 0xe8, 0x5b, 0x68, 0x5f, 0xe8, 0x5b, 0x68, 0x1c, 0xe8, 0x5f, 0xe8, 0x00, 0x00 };
const unsigned char Lock[] PROGMEM = { 0xe0, 0x1c, 0xc0, 0x0c, 0x8f, 0xc4, 0x9f, 0xe4, 0x9f, 0xe4, 0x9f, 0xe4, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x07, 0x80, 0x07, 0x80, 0x03, 0x00, 0x80, 0x04 };
const unsigned char Set19[] PROGMEM = { 0xf8, 0x7c, 0x80, 0x04, 0xbc, 0xf4, 0x3f, 0xf0, 0x38, 0x70, 0xb7, 0xb4, 0xb6, 0xb4, 0xb5, 0xb4, 0xb7, 0xb4, 0x38, 0x70, 0x3f, 0xf0, 0xbc, 0xf4, 0x80, 0x04, 0xf8, 0x7c };
const unsigned char *Ico_table[] = {
  Set0, Set1, Set2, Set3, Set4, Set5, Set19, Set6, Lock, Set_LANG, QRC, Set7,
  Set8, Set9, Set0, Set10, Set12, Save,
  Set0, Set11, Set14, Save,
  Set11, Set13, Set14, Save,
  Set15, Set16,
  Set17, Set18, //5
  Set5_1, Set5,
  c_NO, Set7,
  Lang_CN, Lang_EN, Lang_JP, //8
  Set4, Set4F, Save,
};
const byte Menu_table[] = {12, 6, 4, 4, 2, 2, 2, 2, 3, 3}; //菜单 标签 温控 定时 控制方式 首页 蜂鸣器 标签删除确认界面 语言菜单 翻转 显示
byte MenuLevel = 0; //菜单层级

/*////////////////////////////////////////////////////////////////////////////////////////////////////
   多语言支持
   Multilingual support
   ///////////////////////////////////////////////////////////////////////////////////////////////////
*/
/*
    英语库  ENGLISH
*/
const char EN_0[] PROGMEM = "Tip";
const char EN_1[] PROGMEM = "Temp";
const char EN_2[] PROGMEM = "Timer";
const char EN_3[] PROGMEM = "Control";
const char EN_4[] PROGMEM = "Screen";
const char EN_5[] PROGMEM = "Buzzer";
const char EN_6[] PROGMEM = "LOW Vol";
const char EN_7[] PROGMEM = "Lang";
const char EN_8[] PROGMEM = "Return";
const char EN_9[] PROGMEM = "Change";
const char EN_10[] PROGMEM = "Calibrate";
const char EN_11[] PROGMEM = "Rename";
const char EN_12[] PROGMEM = "Delete";
const char EN_13[] PROGMEM = "Add";
const char EN_14[] PROGMEM = "Save";
const char EN_15[] PROGMEM = "Default";
const char EN_16[] PROGMEM = "Sleep";
const char EN_17[] PROGMEM = "Boost";
const char EN_18[] PROGMEM = "Save";
const char EN_19[] PROGMEM = "Sleep";
const char EN_20[] PROGMEM = "Off";
const char EN_21[] PROGMEM = "Boost";
const char EN_22[] PROGMEM = "Save";
const char EN_23[] PROGMEM = "Direct";
const char EN_24[] PROGMEM = "PID";
const char EN_25[] PROGMEM = "Big";
const char EN_26[] PROGMEM = "Infos";
const char EN_27[] PROGMEM = "OFF";
const char EN_28[] PROGMEM = "ON";
const char EN_29[] PROGMEM = "NO";
const char EN_30[] PROGMEM = "YES";
const char EN_31[] PROGMEM = "CN";
const char EN_32[] PROGMEM = "EN";
const char EN_33[] PROGMEM = "NO";
const char EN_34[] PROGMEM = "OK";
const char EN_35[] PROGMEM = "Main Screen";
const char EN_36[] PROGMEM = "Flip";
const char EN_37[] PROGMEM = "Save";
const char EN_38[] PROGMEM = "About";
const char EN_39[] PROGMEM = "JP";
const char EN_40[] PROGMEM = "Lock";
const char EN_41[] PROGMEM = "Rotary";
const char *const EN_table[] PROGMEM = {EN_0, EN_1, EN_2, EN_3, EN_4, EN_5, EN_41, EN_6, EN_40, EN_7, EN_38, EN_8, EN_9, EN_10, EN_11, EN_12, EN_13, EN_14, EN_15, EN_16, EN_17, EN_18, EN_19, EN_20, EN_21, EN_22, EN_23, EN_24, EN_25, EN_26, EN_27, EN_28, EN_29, EN_30, EN_31, EN_32, EN_39, EN_35, EN_36, EN_37,};

/*
  #!/usr/bin/python
  # -*- coding: UTF-8 -*-
  for num in range(0,38):
  print("EN_",end="")
  print(num,end='')
  print(",",end="")
*/
/*
    中文语言库 CHINESE

  ////////////////////////////////////////////////////////////////////////////////////////////////////////
   本地化提示：你可以按照位图的大小，把这里的文字位图替换成你的语言，确保位图分辨率一致即可，我们欢迎你把程序翻译为你当地的语言！
  Localization tips: you can according to the size of the bitmap,
  replace the text bitmap here with your language,
  ensure that the bitmap resolution is consistent,
  we welcome you to translate the program into your local language!
  ////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
//width:28,height:14 主界面中文提示
//Main Screen
//错误-ERROR
const unsigned char S1[] PROGMEM = { 0x20, 0x92, 0x1f, 0xc0, 0x3d, 0xf9, 0x90, 0x40, 0x20, 0x90, 0x90, 0x40, 0x40, 0x90, 0x1f, 0xc0, 0x7b, 0xff, 0x00, 0x00, 0xa0, 0x01, 0x3f, 0xe0, 0x21, 0xf9, 0x02, 0x00, 0xfd, 0x09, 0x02, 0x00, 0x21, 0x09, 0x7f, 0xf0, 0x21, 0xf9, 0x05, 0x00, 0x21, 0x09, 0x45, 0x00, 0x29, 0x09, 0x88, 0x80, 0x31, 0xf9, 0x10, 0x70, 0x21, 0x08, 0x20, 0x20 };
//关机-OFF
const unsigned char S2[] PROGMEM = { 0x10, 0x40, 0x47, 0xc0, 0x17, 0xfc, 0x44, 0x40, 0x20, 0x03, 0xf4, 0x40, 0x23, 0xf8, 0x44, 0x40, 0x62, 0x08, 0xc4, 0x40, 0xa3, 0xf8, 0xe4, 0x40, 0x20, 0x01, 0x54, 0x40, 0x2f, 0xfd, 0x44, 0x40, 0x28, 0x06, 0x44, 0x40, 0x23, 0xf8, 0x44, 0x40, 0x20, 0x40, 0x44, 0x50, 0x20, 0x40, 0x48, 0x50, 0x21, 0x40, 0x50, 0x30, 0x20, 0x80, 0x40, 0x00 };
//休眠-SLEEP
const unsigned char S3[] PROGMEM = { 0x10, 0x83, 0xdf, 0xc0, 0x10, 0x82, 0x50, 0x40, 0x20, 0x82, 0x50, 0x40, 0x2f, 0xff, 0xdf, 0xc0, 0x60, 0x82, 0x52, 0x00, 0x61, 0xc2, 0x52, 0x00, 0xa1, 0xc2, 0x5f, 0xe0, 0x22, 0xa3, 0xd2, 0x00, 0x22, 0xa2, 0x51, 0x00, 0x24, 0x92, 0x51, 0x00, 0x28, 0x8e, 0x50, 0x90, 0x30, 0x8b, 0xd4, 0x50, 0x20, 0x82, 0x58, 0x30, 0x20, 0x80, 0x10, 0x10 };
//提温-BOOST
const unsigned char S4[] PROGMEM = { 0x23, 0xf2, 0x1f, 0xc0, 0x22, 0x11, 0x10, 0x40, 0xfb, 0xf0, 0x90, 0x40, 0x22, 0x12, 0x1f, 0xc0, 0x2a, 0x11, 0x10, 0x40, 0x33, 0xf1, 0x10, 0x40, 0x60, 0x00, 0x5f, 0xc0, 0xaf, 0xfc, 0x80, 0x00, 0x20, 0x41, 0x3f, 0xe0, 0x22, 0x43, 0x25, 0x20, 0x22, 0x79, 0x25, 0x20, 0x22, 0x41, 0x25, 0x20, 0xa5, 0x41, 0x25, 0x20, 0x48, 0xfd, 0x7f, 0xf0 };
//正常工作-WORKY
const unsigned char S5[] PROGMEM = { 0x7f, 0xf8, 0x48, 0x80, 0x02, 0x00, 0x49, 0x00, 0x02, 0x01, 0xff, 0xf0, 0x02, 0x01, 0x00, 0x10, 0x02, 0x02, 0x7f, 0x20, 0x22, 0x00, 0x41, 0x00, 0x23, 0xf0, 0x7f, 0x00, 0x22, 0x00, 0x08, 0x00, 0x22, 0x00, 0xff, 0x80, 0x22, 0x00, 0x88, 0x80, 0x22, 0x00, 0x88, 0x80, 0x22, 0x00, 0x8a, 0x80, 0x22, 0x00, 0x89, 0x00, 0xff, 0xfc, 0x08, 0x00 };
//加热-HEAT
const unsigned char S6[] PROGMEM = { 0x0f, 0x42, 0x1f, 0xc0, 0x78, 0x41, 0x10, 0x40, 0x08, 0x40, 0x90, 0x40, 0x08, 0x42, 0x1f, 0xc0, 0x08, 0x41, 0x10, 0x40, 0xff, 0xfd, 0x10, 0x40, 0x08, 0x40, 0x5f, 0xc0, 0x08, 0x40, 0x80, 0x00, 0x08, 0x41, 0x3f, 0xe0, 0x08, 0x43, 0x25, 0x20, 0x10, 0x41, 0x25, 0x20, 0x10, 0x41, 0x25, 0x20, 0x20, 0x41, 0x25, 0x20, 0x40, 0x41, 0x7f, 0xf0 };
//维持-HOLD
const unsigned char S7[] PROGMEM = { 0x11, 0x40, 0x82, 0x00, 0x21, 0x20, 0x8f, 0xe0, 0x23, 0xfc, 0x82, 0x00, 0x4a, 0x23, 0xe2, 0x00, 0xfe, 0x20, 0x9f, 0xf0, 0x13, 0xf8, 0x80, 0x80, 0x22, 0x20, 0xc0, 0x80, 0x42, 0x21, 0xbf, 0xf0, 0xfb, 0xfa, 0x88, 0x80, 0x02, 0x20, 0x84, 0x80, 0x02, 0x20, 0x84, 0x80, 0x1a, 0x20, 0x80, 0x80, 0xe3, 0xfe, 0x82, 0x80, 0x02, 0x01, 0x01, 0x00 };
const unsigned char *S_table[] = {S1, S2, S3, S4, S5, S6, S7};

// 菜单  width:36,height:16
//MENU Oj
/*
   The order here(↓) can refer to EN_table(↑↑↑)
*/
const unsigned char t0[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x7f, 0x90, 0xf8, 0x00, 0x01, 0x08, 0x08, 0x88, 0x00, 0x0a, 0x10, 0x08, 0x88, 0x00, 0x04, 0x7f, 0x01, 0x07, 0x00, 0x1f, 0xc1, 0x3a, 0x00, 0x00, 0x05, 0x49, 0x09, 0xfc, 0x00, 0x04, 0x49, 0x08, 0x84, 0x00, 0x04, 0x49, 0x08, 0x88, 0x00, 0x04, 0x49, 0x08, 0x48, 0x00, 0x04, 0x49, 0x08, 0x50, 0x00, 0x04, 0x49, 0x0a, 0x20, 0x00, 0x04, 0x16, 0x0c, 0x58, 0x00, 0x14, 0x21, 0x89, 0x87, 0x00, 0x08, 0xc0, 0x86, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t1[] PROGMEM  = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xfe, 0x08, 0x20, 0x00, 0x08, 0x82, 0x0b, 0xff, 0x00, 0x04, 0x82, 0x0a, 0x01, 0x00, 0x10, 0xfe, 0x3c, 0x51, 0x00, 0x08, 0x82, 0x08, 0x88, 0x00, 0x08, 0x82, 0x09, 0x04, 0x00, 0x02, 0xfe, 0x0c, 0x00, 0x00, 0x04, 0x00, 0x19, 0xfc, 0x00, 0x09, 0xff, 0x28, 0x20, 0x00, 0x19, 0x29, 0x08, 0x20, 0x00, 0x09, 0x29, 0x08, 0x20, 0x00, 0x09, 0x29, 0x08, 0x20, 0x00, 0x09, 0x29, 0x2b, 0xff, 0x00, 0x0b, 0xff, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t2[] PROGMEM  = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3e, 0x04, 0x00, 0x1f, 0xff, 0xa2, 0x04, 0x00, 0x10, 0x00, 0xa2, 0xff, 0x00, 0x00, 0x01, 0x22, 0x04, 0x00, 0x0f, 0xfe, 0x22, 0x04, 0x00, 0x00, 0x40, 0x3e, 0x44, 0x00, 0x00, 0x40, 0x22, 0x24, 0x00, 0x04, 0x40, 0x22, 0x24, 0x00, 0x04, 0x7c, 0x22, 0x04, 0x00, 0x04, 0x40, 0x22, 0x04, 0x00, 0x0a, 0x40, 0x3e, 0x04, 0x00, 0x09, 0x40, 0x22, 0x24, 0x00, 0x10, 0xff, 0x80, 0x14, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00 };
const unsigned char t3[] PROGMEM  = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x12, 0x02, 0x00, 0x05, 0xff, 0x9f, 0xd2, 0x00, 0x05, 0x00, 0x92, 0x12, 0x00, 0x1e, 0x28, 0xa2, 0x12, 0x00, 0x04, 0x44, 0x3f, 0xf2, 0x00, 0x04, 0x82, 0x02, 0x12, 0x00, 0x06, 0x00, 0x02, 0x12, 0x00, 0x0c, 0xfe, 0x1f, 0xd2, 0x00, 0x14, 0x10, 0x12, 0x52, 0x00, 0x04, 0x10, 0x12, 0x42, 0x00, 0x04, 0x10, 0x13, 0x42, 0x00, 0x04, 0x10, 0x12, 0x82, 0x00, 0x15, 0xff, 0x82, 0x0a, 0x00, 0x08, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t4[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x0f, 0xf8, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x04, 0x02, 0x3f, 0xfe, 0x00, 0x04, 0x02, 0x00, 0x80, 0x00, 0x07, 0xfe, 0x00, 0x80, 0x00, 0x00, 0x90, 0x04, 0x90, 0x00, 0x08, 0x91, 0x0c, 0x88, 0x00, 0x06, 0x93, 0x10, 0x86, 0x00, 0x02, 0x94, 0x20, 0x82, 0x00, 0x00, 0x90, 0x00, 0x80, 0x00, 0x00, 0x90, 0x02, 0x80, 0x00, 0x1f, 0xff, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t5[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x1f, 0xff, 0x9f, 0xfc, 0x00, 0x00, 0x40, 0x04, 0x10, 0x00, 0x0f, 0xff, 0x02, 0x20, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x08, 0x42, 0x0f, 0xf8, 0x00, 0x08, 0x42, 0x08, 0x08, 0x00, 0x0f, 0xfe, 0x08, 0x08, 0x00, 0x08, 0x02, 0x0f, 0xf8, 0x00, 0x08, 0x00, 0x08, 0x08, 0x00, 0x08, 0x00, 0x08, 0x08, 0x00, 0x08, 0x00, 0x0f, 0xf8, 0x00, 0x10, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t6[] PROGMEM = { 0x09, 0xff, 0x00, 0x40, 0x00, 0x04, 0x20, 0x3f, 0xff, 0x00, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x1c, 0x42, 0x0f, 0xfc, 0x00, 0x04, 0x42, 0x00, 0x00, 0x00, 0x07, 0xff, 0x80, 0x00, 0x00, 0x04, 0x00, 0x0f, 0xfc, 0x00, 0x04, 0xff, 0x00, 0x00, 0x00, 0x04, 0x81, 0x00, 0x00, 0x00, 0x05, 0x81, 0x0f, 0xfc, 0x00, 0x06, 0x81, 0x08, 0x04, 0x00, 0x04, 0xff, 0x08, 0x04, 0x00, 0x00, 0x81, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

const unsigned char t7[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0f, 0xfe, 0x00, 0x01, 0x00, 0x08, 0x20, 0x00, 0x03, 0xff, 0x08, 0x20, 0x00, 0x02, 0x01, 0x08, 0x20, 0x00, 0x04, 0x22, 0x08, 0x20, 0x00, 0x08, 0x20, 0x0b, 0xfe, 0x00, 0x10, 0x20, 0x08, 0x20, 0x00, 0x00, 0x50, 0x08, 0x28, 0x00, 0x00, 0x50, 0x08, 0x24, 0x00, 0x00, 0x88, 0x08, 0x22, 0x00, 0x00, 0x88, 0x10, 0x20, 0x00, 0x01, 0x04, 0x10, 0x20, 0x00, 0x02, 0x03, 0xa7, 0xff, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char Back[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0x00, 0x00, 0x00, 0x08, 0xf8, 0x3f, 0xfe, 0x00, 0x04, 0x80, 0x20, 0x02, 0x00, 0x00, 0x80, 0x20, 0x02, 0x00, 0x00, 0xbe, 0x23, 0xe2, 0x00, 0x1c, 0x82, 0x22, 0x22, 0x00, 0x04, 0xa4, 0x22, 0x22, 0x00, 0x04, 0x94, 0x22, 0x22, 0x00, 0x04, 0x88, 0x22, 0x22, 0x00, 0x04, 0x94, 0x23, 0xe2, 0x00, 0x05, 0x22, 0x20, 0x02, 0x00, 0x05, 0x42, 0x20, 0x02, 0x00, 0x0a, 0x00, 0x3f, 0xfe, 0x00, 0x11, 0xff, 0xa0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

const unsigned char t1_1[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x20, 0x90, 0x00, 0x02, 0x7f, 0x98, 0x90, 0x00, 0x1f, 0x80, 0x09, 0xff, 0x00, 0x02, 0x22, 0x01, 0x10, 0x00, 0x06, 0x21, 0x8b, 0x10, 0x00, 0x07, 0x62, 0x8d, 0xfe, 0x00, 0x0a, 0xa2, 0x09, 0x10, 0x00, 0x0a, 0x14, 0x11, 0x10, 0x00, 0x12, 0x14, 0x31, 0xfe, 0x00, 0x02, 0x08, 0x11, 0x10, 0x00, 0x02, 0x14, 0x11, 0x10, 0x00, 0x02, 0x22, 0x11, 0x10, 0x00, 0x02, 0x43, 0x91, 0xff, 0x00, 0x02, 0x81, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t1_2[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x80, 0x00, 0x00, 0x50, 0x01, 0xfc, 0x00, 0x00, 0x88, 0x01, 0x04, 0x00, 0x01, 0x04, 0x03, 0x08, 0x00, 0x06, 0xfb, 0x04, 0x90, 0x00, 0x08, 0x00, 0xc0, 0x60, 0x00, 0x07, 0xdf, 0x01, 0x80, 0x00, 0x04, 0x51, 0x06, 0x00, 0x00, 0x04, 0x51, 0x1b, 0xfe, 0x00, 0x04, 0x51, 0x02, 0x02, 0x00, 0x07, 0xd9, 0x02, 0x02, 0x00, 0x04, 0x56, 0x02, 0x02, 0x00, 0x00, 0x10, 0x03, 0xfe, 0x00, 0x00, 0x10, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t1_3[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x78, 0xbc, 0x20, 0x00, 0x09, 0x48, 0xa4, 0x50, 0x00, 0x09, 0x4a, 0xa8, 0x50, 0x00, 0x09, 0x4a, 0xa8, 0x88, 0x00, 0x09, 0x4a, 0xb1, 0x04, 0x00, 0x1f, 0xfe, 0xaa, 0xfb, 0x00, 0x09, 0x4a, 0xa4, 0x20, 0x00, 0x09, 0x4a, 0xa4, 0x20, 0x00, 0x09, 0x4a, 0xa7, 0xfe, 0x00, 0x09, 0x4a, 0xb4, 0x20, 0x00, 0x09, 0x48, 0xa9, 0x24, 0x00, 0x0b, 0x48, 0xa2, 0x22, 0x00, 0x08, 0x8a, 0xa4, 0xa2, 0x00, 0x11, 0x19, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t1_4[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x10, 0x00, 0x1f, 0xdc, 0x3e, 0xfe, 0x00, 0x08, 0x90, 0x02, 0x12, 0x00, 0x05, 0x10, 0x04, 0xff, 0x00, 0x1f, 0xdf, 0x84, 0x12, 0x00, 0x02, 0x12, 0x0c, 0xfe, 0x00, 0x1f, 0xd2, 0x02, 0x10, 0x00, 0x02, 0x12, 0x22, 0xfe, 0x00, 0x0a, 0x92, 0x14, 0x10, 0x00, 0x0a, 0x52, 0x14, 0x10, 0x00, 0x12, 0x22, 0x0d, 0xff, 0x00, 0x02, 0x22, 0x08, 0x10, 0x00, 0x0a, 0x42, 0x14, 0x10, 0x00, 0x04, 0x02, 0x23, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
//默认
const unsigned char t2_0[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc8, 0x10, 0x20, 0x00, 0x12, 0x4a, 0x0c, 0x20, 0x00, 0x1a, 0xc9, 0x04, 0x20, 0x00, 0x17, 0x48, 0x00, 0x20, 0x00, 0x1f, 0xff, 0xb8, 0x20, 0x00, 0x02, 0x08, 0x08, 0x50, 0x00, 0x1f, 0xc8, 0x08, 0x50, 0x00, 0x02, 0x08, 0x08, 0x50, 0x00, 0x03, 0xc8, 0x08, 0x48, 0x00, 0x1e, 0x14, 0x08, 0x88, 0x00, 0x01, 0x54, 0x0a, 0x88, 0x00, 0x15, 0x22, 0x0c, 0x84, 0x00, 0x14, 0x43, 0x89, 0x07, 0x00, 0x00, 0x81, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
//休眠
const unsigned char t2_1[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x3d, 0xfc, 0x00, 0x02, 0x10, 0x25, 0x04, 0x00, 0x04, 0x10, 0x25, 0x04, 0x00, 0x05, 0xff, 0xbd, 0xfc, 0x00, 0x0c, 0x10, 0x25, 0x20, 0x00, 0x0c, 0x38, 0x25, 0x20, 0x00, 0x14, 0x38, 0x25, 0xfe, 0x00, 0x04, 0x54, 0x3d, 0x20, 0x00, 0x04, 0x54, 0x25, 0x10, 0x00, 0x04, 0x92, 0x25, 0x10, 0x00, 0x05, 0x11, 0xa5, 0x09, 0x00, 0x06, 0x11, 0x3d, 0x45, 0x00, 0x04, 0x10, 0x25, 0x83, 0x00, 0x04, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
//提温
const unsigned char t2_2[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x7e, 0x21, 0xfc, 0x00, 0x04, 0x42, 0x11, 0x04, 0x00, 0x1f, 0x7e, 0x09, 0x04, 0x00, 0x04, 0x42, 0x21, 0xfc, 0x00, 0x05, 0x42, 0x11, 0x04, 0x00, 0x06, 0x7e, 0x11, 0x04, 0x00, 0x0c, 0x00, 0x05, 0xfc, 0x00, 0x15, 0xff, 0x88, 0x00, 0x00, 0x04, 0x08, 0x13, 0xfe, 0x00, 0x04, 0x48, 0x32, 0x52, 0x00, 0x04, 0x4f, 0x12, 0x52, 0x00, 0x04, 0x48, 0x12, 0x52, 0x00, 0x14, 0xa8, 0x12, 0x52, 0x00, 0x09, 0x1f, 0x97, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
//关机
const unsigned char t3_1[] PROGMEM = { 0x01, 0x04, 0x04, 0x7c, 0x00, 0x00, 0x88, 0x04, 0x44, 0x00, 0x0f, 0xff, 0x3f, 0x44, 0x00, 0x00, 0x20, 0x04, 0x44, 0x00, 0x00, 0x20, 0x0c, 0x44, 0x00, 0x00, 0x20, 0x0e, 0x44, 0x00, 0x1f, 0xff, 0x95, 0x44, 0x00, 0x00, 0x20, 0x14, 0x44, 0x00, 0x00, 0x50, 0x24, 0x44, 0x00, 0x00, 0x50, 0x04, 0x44, 0x00, 0x00, 0x88, 0x04, 0x45, 0x00, 0x01, 0x04, 0x04, 0x85, 0x00, 0x06, 0x03, 0x85, 0x03, 0x00, 0x18, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

const unsigned char t_4[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x08, 0x20, 0x00, 0x0f, 0xff, 0x09, 0xfc, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00, 0x20, 0x3e, 0x88, 0x00, 0x03, 0xfe, 0x08, 0x50, 0x00, 0x02, 0x02, 0x0b, 0xfe, 0x00, 0x03, 0xfe, 0x0c, 0x40, 0x00, 0x02, 0x02, 0x18, 0x40, 0x00, 0x03, 0xfe, 0x2b, 0xfe, 0x00, 0x02, 0x02, 0x08, 0x48, 0x00, 0x03, 0xfe, 0x08, 0x88, 0x00, 0x02, 0x02, 0x08, 0x50, 0x00, 0x02, 0x02, 0x28, 0x30, 0x00, 0x1f, 0xff, 0x91, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t_PID[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc3, 0xf1, 0xe0, 0x00, 0x0f, 0xe3, 0xf1, 0xf8, 0x00, 0x0c, 0x70, 0xc1, 0x9e, 0x00, 0x0c, 0x30, 0xc1, 0x86, 0x00, 0x0c, 0x30, 0xc1, 0x83, 0x00, 0x0c, 0x30, 0xc1, 0x83, 0x00, 0x0c, 0x60, 0xc1, 0x83, 0x00, 0x0c, 0x60, 0xc1, 0x83, 0x00, 0x0f, 0xc0, 0xc1, 0x83, 0x00, 0x0f, 0xc0, 0xc1, 0x86, 0x00, 0x0c, 0x00, 0xc1, 0x86, 0x00, 0x0c, 0x00, 0xc1, 0x98, 0x00, 0x0c, 0x03, 0xf1, 0xf8, 0x00, 0x0c, 0x03, 0xf1, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

const unsigned char t5_0[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xdf, 0x88, 0x40, 0x00, 0x0a, 0x24, 0x10, 0x40, 0x00, 0x11, 0x42, 0x10, 0xfe, 0x00, 0x04, 0x00, 0x22, 0x82, 0x00, 0x02, 0xff, 0x3d, 0x02, 0x00, 0x08, 0x01, 0x0a, 0x42, 0x00, 0x09, 0xf9, 0x10, 0x32, 0x00, 0x09, 0x09, 0x20, 0x12, 0x00, 0x09, 0xf9, 0x3e, 0x02, 0x00, 0x09, 0x09, 0x00, 0x02, 0x00, 0x09, 0x09, 0x0e, 0x02, 0x00, 0x09, 0xf9, 0x30, 0x22, 0x00, 0x08, 0x05, 0x00, 0x14, 0x00, 0x08, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t5_1[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x44, 0x10, 0xfe, 0x00, 0x04, 0x28, 0x10, 0x92, 0x00, 0x05, 0xff, 0x22, 0x92, 0x00, 0x00, 0x10, 0x3c, 0x92, 0x00, 0x00, 0x10, 0x08, 0x92, 0x00, 0x1c, 0xfe, 0x10, 0x92, 0x00, 0x04, 0x10, 0x20, 0xfe, 0x00, 0x04, 0x10, 0x3e, 0x92, 0x00, 0x05, 0xff, 0x80, 0x92, 0x00, 0x04, 0x10, 0x00, 0x92, 0x00, 0x05, 0x10, 0x0e, 0x92, 0x00, 0x06, 0x10, 0x30, 0x92, 0x00, 0x04, 0x10, 0x00, 0xfe, 0x00, 0x00, 0x10, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t5_3[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x3f, 0xfe, 0x00, 0x1f, 0xff, 0x81, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x07, 0xfe, 0x0f, 0xf8, 0x00, 0x04, 0x02, 0x08, 0x08, 0x00, 0x04, 0x02, 0x08, 0x88, 0x00, 0x07, 0xfe, 0x08, 0x88, 0x00, 0x04, 0x02, 0x08, 0x88, 0x00, 0x04, 0x02, 0x08, 0x88, 0x00, 0x07, 0xfe, 0x08, 0x88, 0x00, 0x04, 0x02, 0x09, 0x48, 0x00, 0x04, 0x02, 0x02, 0x30, 0x00, 0x07, 0xfe, 0x04, 0x0c, 0x00, 0x04, 0x02, 0x18, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

const unsigned char t_off[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x04, 0xff, 0x00, 0x00, 0x44, 0x02, 0x01, 0x00, 0x07, 0xff, 0x90, 0x21, 0x00, 0x00, 0x10, 0x10, 0x21, 0x00, 0x00, 0x10, 0x17, 0xfd, 0x00, 0x00, 0x10, 0x10, 0x21, 0x00, 0x0f, 0xff, 0xd0, 0x61, 0x00, 0x00, 0x10, 0x10, 0xa1, 0x00, 0x00, 0x28, 0x11, 0x21, 0x00, 0x00, 0x28, 0x12, 0x21, 0x00, 0x00, 0x44, 0x14, 0x21, 0x00, 0x00, 0x82, 0x10, 0xa1, 0x00, 0x03, 0x01, 0xd0, 0x45, 0x00, 0x0c, 0x00, 0x90, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t_on[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x80, 0x20, 0x00, 0x00, 0x84, 0x07, 0xff, 0x00, 0x00, 0x84, 0x04, 0x01, 0x00, 0x00, 0x84, 0x04, 0x01, 0x00, 0x00, 0x84, 0x04, 0x01, 0x00, 0x0f, 0xff, 0xc7, 0xff, 0x00, 0x00, 0x84, 0x04, 0x00, 0x00, 0x00, 0x84, 0x04, 0x00, 0x00, 0x00, 0x84, 0x05, 0xff, 0x00, 0x00, 0x84, 0x05, 0x01, 0x00, 0x01, 0x04, 0x09, 0x01, 0x00, 0x01, 0x04, 0x09, 0x01, 0x00, 0x02, 0x04, 0x11, 0xff, 0x00, 0x04, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

const unsigned char t_NO[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x04, 0x91, 0x00, 0x04, 0x40, 0x02, 0x52, 0x00, 0x04, 0x7f, 0x90, 0x54, 0x00, 0x04, 0x50, 0x88, 0xff, 0x00, 0x07, 0xd0, 0x84, 0x81, 0x00, 0x04, 0x51, 0x00, 0x81, 0x00, 0x04, 0x49, 0x01, 0xff, 0x00, 0x07, 0xca, 0x02, 0x81, 0x00, 0x04, 0x44, 0x04, 0x81, 0x00, 0x04, 0x4a, 0x1c, 0xff, 0x00, 0x07, 0xea, 0x04, 0x81, 0x00, 0x0c, 0x51, 0x04, 0x81, 0x00, 0x00, 0x61, 0xc4, 0x85, 0x00, 0x00, 0x40, 0x80, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t_OK[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xdf, 0x10, 0x20, 0x00, 0x02, 0x12, 0x0c, 0x20, 0x00, 0x02, 0x24, 0x04, 0x20, 0x00, 0x04, 0x7f, 0x80, 0x20, 0x00, 0x04, 0x24, 0xb8, 0x20, 0x00, 0x0f, 0xa4, 0x88, 0x50, 0x00, 0x14, 0xbf, 0x88, 0x50, 0x00, 0x04, 0xa4, 0x88, 0x50, 0x00, 0x04, 0xa4, 0x88, 0x48, 0x00, 0x04, 0xbf, 0x88, 0x88, 0x00, 0x04, 0xa4, 0x8a, 0x88, 0x00, 0x07, 0xa4, 0x8c, 0x84, 0x00, 0x04, 0x44, 0x89, 0x07, 0x00, 0x00, 0x81, 0x86, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

const unsigned char t_CN_CN[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x0f, 0xff, 0x3f, 0xff, 0x00, 0x08, 0x41, 0x04, 0x08, 0x00, 0x08, 0x41, 0x04, 0x08, 0x00, 0x08, 0x41, 0x04, 0x10, 0x00, 0x08, 0x41, 0x02, 0x10, 0x00, 0x0f, 0xff, 0x02, 0x20, 0x00, 0x08, 0x41, 0x01, 0x20, 0x00, 0x00, 0x40, 0x00, 0xc0, 0x00, 0x00, 0x40, 0x01, 0x30, 0x00, 0x00, 0x40, 0x02, 0x08, 0x00, 0x00, 0x40, 0x0c, 0x07, 0x00, 0x00, 0x40, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t_CN_EN[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x80, 0x00, 0x1f, 0xff, 0x80, 0x80, 0x00, 0x01, 0x10, 0x3f, 0xff, 0x00, 0x00, 0x40, 0x04, 0x08, 0x00, 0x07, 0xfc, 0x04, 0x08, 0x00, 0x04, 0x44, 0x04, 0x10, 0x00, 0x04, 0x44, 0x02, 0x10, 0x00, 0x04, 0x44, 0x02, 0x20, 0x00, 0x1f, 0xff, 0x81, 0x20, 0x00, 0x00, 0x40, 0x00, 0xc0, 0x00, 0x00, 0xa0, 0x01, 0x30, 0x00, 0x01, 0x10, 0x02, 0x08, 0x00, 0x06, 0x0c, 0x0c, 0x07, 0x00, 0x18, 0x03, 0xb0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t_CN_JP[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x13, 0xfe, 0x00, 0x04, 0x02, 0x08, 0x40, 0x00, 0x04, 0x02, 0x08, 0x40, 0x00, 0x04, 0x02, 0x01, 0xfc, 0x00, 0x04, 0x02, 0x38, 0x84, 0x00, 0x04, 0x02, 0x08, 0x84, 0x00, 0x07, 0xfe, 0x0f, 0xff, 0x00, 0x04, 0x02, 0x08, 0x00, 0x00, 0x04, 0x02, 0x09, 0xfe, 0x00, 0x04, 0x02, 0x09, 0x02, 0x00, 0x04, 0x02, 0x0b, 0x02, 0x00, 0x04, 0x02, 0x0d, 0x02, 0x00, 0x07, 0xfe, 0x09, 0xfe, 0x00, 0x04, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

//翻转
const unsigned char t4f[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1d, 0xc2, 0x08, 0x00, 0x05, 0x44, 0x42, 0x08, 0x00, 0x03, 0x84, 0x5f, 0xbf, 0x00, 0x0f, 0xe4, 0x44, 0x10, 0x00, 0x01, 0x15, 0x45, 0x10, 0x00, 0x05, 0x4c, 0xc9, 0x7f, 0x80, 0x09, 0x24, 0x4f, 0x90, 0x00, 0x07, 0xc4, 0xc1, 0x10, 0x00, 0x05, 0x4d, 0x41, 0x3f, 0x00, 0x05, 0x54, 0x43, 0x81, 0x00, 0x07, 0xc4, 0x4d, 0x02, 0x00, 0x05, 0x44, 0x41, 0x14, 0x00, 0x05, 0x55, 0x41, 0x08, 0x00, 0x07, 0xc8, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
//保存
const unsigned char t_save[] PROGMEM = { 0x02, 0xfe, 0x01, 0x00, 0x00, 0x02, 0x82, 0x3f, 0xff, 0x00, 0x04, 0x82, 0x02, 0x00, 0x00, 0x04, 0xfe, 0x02, 0x00, 0x00, 0x0c, 0x10, 0x04, 0xfc, 0x00, 0x14, 0x10, 0x04, 0x08, 0x00, 0x05, 0xff, 0x8c, 0x10, 0x00, 0x04, 0x10, 0x14, 0x10, 0x00, 0x04, 0x38, 0x25, 0xff, 0x00, 0x04, 0x34, 0x04, 0x10, 0x00, 0x04, 0x52, 0x04, 0x10, 0x00, 0x04, 0x91, 0x84, 0x10, 0x00, 0x05, 0x10, 0x04, 0x50, 0x00, 0x04, 0x10, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char tAbout[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x0f, 0xfe, 0x00, 0x00, 0x44, 0x00, 0x40, 0x00, 0x07, 0xff, 0x80, 0x40, 0x00, 0x00, 0x10, 0x00, 0x40, 0x00, 0x00, 0x10, 0x00, 0x40, 0x00, 0x00, 0x10, 0x1f, 0xff, 0x80, 0x0f, 0xff, 0xc0, 0x40, 0x00, 0x00, 0x10, 0x00, 0x40, 0x00, 0x00, 0x28, 0x00, 0x40, 0x00, 0x00, 0x28, 0x00, 0x40, 0x00, 0x00, 0x44, 0x00, 0x40, 0x00, 0x00, 0x82, 0x00, 0x40, 0x00, 0x03, 0x01, 0xc1, 0x40, 0x00, 0x0c, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char tPassword[] PROGMEM = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x1f, 0x7e, 0x00, 0x1f, 0xff, 0x84, 0x02, 0x00, 0x10, 0x80, 0x84, 0x42, 0x00, 0x0a, 0x4a, 0x04, 0x42, 0x00, 0x0a, 0x31, 0x08, 0x42, 0x00, 0x12, 0xc5, 0x0f, 0x42, 0x00, 0x03, 0x04, 0x19, 0x7f, 0x00, 0x1d, 0xf8, 0x29, 0x01, 0x00, 0x00, 0x40, 0x09, 0x01, 0x00, 0x08, 0x42, 0x09, 0xfd, 0x00, 0x08, 0x42, 0x09, 0x01, 0x00, 0x08, 0x42, 0x0f, 0x01, 0x00, 0x0f, 0xfe, 0x09, 0x05, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char t19[] PROGMEM = { 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x1f, 0x88, 0xfe, 0x00, 0x1f, 0xd0, 0x0e, 0x22, 0x00, 0x04, 0x20, 0x30, 0x22, 0x00, 0x04, 0x5f, 0x80, 0x22, 0x00, 0x07, 0x84, 0x9e, 0x22, 0x00, 0x04, 0x85, 0x08, 0x22, 0x00, 0x04, 0x94, 0x08, 0x22, 0x00, 0x04, 0x94, 0x28, 0xfe, 0x00, 0x04, 0x97, 0x1e, 0x42, 0x00, 0x04, 0x94, 0x08, 0x42, 0x00, 0x08, 0x94, 0x08, 0x42, 0x00, 0x0a, 0xac, 0x0a, 0x42, 0x00, 0x11, 0x44, 0x0c, 0x42, 0x00, 0x00, 0x83, 0x89, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char *CN_table[] = {
  t0, t1, t2, t3, t4, t5, t19 , t7, tPassword, t6, tAbout, Back, //0
  t0, t1_1, t1_2, t1_3, t1_4, t_save,  //1
  t2_0, t2_1, t2_2, t_save, //2
  t2_1, t3_1, t2_2, t_save,//3
  t_4, t_PID,//4
  t5_0, t5_1,//5
  t_off, t_on,//6
  t_NO, t_OK,//7
  t_CN_CN, t_CN_EN, t_CN_JP, //8
  t5_3, t4f, t_save, //9
};
/*
   日语 Japanese
*/
/*
  8x8 dot Japanese font for Arduboy

  Copyright (c) 2016 emutyworks

  Released under the MIT license
  https://github.com/emutyworks/8x8DotJPFont/blob/master/LICENSE.txt
*/

#define MISAKI_FONT_H

#define MISAKI_FONT_F0_PAGE 0xF0
#define MISAKI_FONT_F1_PAGE 0xF1
#define MISAKI_FONT_F2_PAGE 0xF2

#define MISAKI_FONT_F0_W 8
#define MISAKI_FONT_F1_W 3
#define MISAKI_FONT_F2_W 7

#define MISAKI_FONT_F0_SIZE 0xEF
#define MISAKI_FONT_F1_SIZE 0x9D
#define MISAKI_FONT_F2_SIZE 0x20 // misaki_font_f2.h の最終行の値をここに設定する、最大0xEFまで

/*
  利用しないフォントデータはヘッダファイルを読み込まないようにするとメモリが節約できます、
  drawText() 実行時にフォントが無い場合は処理がスキップされます。

  例) 8x8 dot ひらがな・カタカナ・記号 のみ利用
  #include "misaki_font_f0.h" // 8x8 dot ひらがな・カタカナ・記号
  //#include "misaki_font_f1.h" // 4x8 dot 英語・カタカナ・記号
  //#include "misaki_font_f2.h" // 8x8 dot 漢字
*/
PROGMEM const uint8_t misaki_font_0x00[1] = { 0x00 };
#define MISAKI_FONT_F0_H
PROGMEM const uint8_t misaki_font_f0[ MISAKI_FONT_F0_SIZE + 1 ][ MISAKI_FONT_F0_W ] =
{
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* 0x00 　 */
  { 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* 0x01 、 */
  { 0x20, 0x50, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* 0x02 。 */
  { 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* 0x03 ， */
  { 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* 0x04 ． */
  { 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00 }, /* 0x05 ・ */
  { 0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00 }, /* 0x06 ： */
  { 0x00, 0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00 }, /* 0x07 ； */
  { 0x00, 0x02, 0x01, 0x51, 0x09, 0x09, 0x06, 0x00 }, /* 0x08 ？ */
  { 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00 }, /* 0x09 ！ */
  { 0x00, 0x00, 0x00, 0x00, 0x7f, 0x41, 0x41, 0x00 }, /* 0x0A ［ */
  { 0x41, 0x41, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* 0x0B ］ */
  { 0x00, 0x00, 0x00, 0x3f, 0x01, 0x01, 0x01, 0x00 }, /* 0x0C 「 */
  { 0x40, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x00, 0x00 }, /* 0x0D 」 */
  { 0x00, 0x00, 0x3f, 0x21, 0x3d, 0x05, 0x07, 0x00 }, /* 0x0E 『 */
  { 0x70, 0x50, 0x5e, 0x42, 0x7e, 0x00, 0x00, 0x00 }, /* 0x0F 』 */
  { 0x00, 0x00, 0x00, 0x00, 0x7f, 0x63, 0x41, 0x00 }, /* 0x10 【 */
  { 0x41, 0x63, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* 0x11 】 */
  { 0x08, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x08, 0x00 }, /* 0x12 ＋ */
  { 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 }, /* 0x13 － */
  { 0x44, 0x44, 0x44, 0x5f, 0x44, 0x44, 0x44, 0x00 }, /* 0x14 ± */
  { 0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41, 0x00 }, /* 0x15 × */
  { 0x08, 0x08, 0x08, 0x2a, 0x08, 0x08, 0x08, 0x00 }, /* 0x16 ÷ */
  { 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00 }, /* 0x17 ＝ */
  { 0x14, 0x34, 0x14, 0x1c, 0x14, 0x16, 0x14, 0x00 }, /* 0x18 ≠ */
  { 0x08, 0x08, 0x14, 0x14, 0x14, 0x22, 0x22, 0x00 }, /* 0x19 ＜ */
  { 0x22, 0x22, 0x14, 0x14, 0x14, 0x08, 0x08, 0x00 }, /* 0x1A ＞ */
  { 0x02, 0x05, 0x02, 0x3c, 0x42, 0x42, 0x24, 0x00 }, /* 0x1B ℃ */
  { 0x00, 0x2b, 0x2c, 0x78, 0x2c, 0x2b, 0x00, 0x00 }, /* 0x1C ￥ */
  { 0x00, 0x24, 0x2a, 0x7a, 0x2f, 0x2a, 0x12, 0x00 }, /* 0x1D ＄ */
  { 0x00, 0x1c, 0x62, 0x32, 0x2e, 0x23, 0x14, 0x00 }, /* 0x1E ￠ */
  { 0x20, 0x54, 0x5e, 0x25, 0x41, 0x42, 0x20, 0x00 }, /* 0x1F ￡ */
  { 0x42, 0x25, 0x12, 0x08, 0x24, 0x52, 0x21, 0x00 }, /* 0x20 ％ */
  { 0x20, 0x62, 0x3e, 0x63, 0x3e, 0x23, 0x02, 0x00 }, /* 0x21 ＃ */
  { 0x20, 0x56, 0x49, 0x55, 0x22, 0x58, 0x40, 0x00 }, /* 0x22 ＆ */
  { 0x00, 0x22, 0x14, 0x7f, 0x14, 0x22, 0x00, 0x00 }, /* 0x23 ＊ */
  { 0x1c, 0x22, 0x59, 0x55, 0x4d, 0x12, 0x0c, 0x00 }, /* 0x24 ＠ */
  { 0x00, 0x00, 0x4a, 0x55, 0x55, 0x29, 0x00, 0x00 }, /* 0x25 § */
  { 0x04, 0x64, 0x3c, 0x17, 0x3c, 0x64, 0x04, 0x00 }, /* 0x26 ☆ */
  { 0x04, 0x64, 0x3c, 0x1f, 0x3c, 0x64, 0x04, 0x00 }, /* 0x27 ★ */
  { 0x1c, 0x22, 0x41, 0x41, 0x41, 0x22, 0x1c, 0x00 }, /* 0x28 ○ */
  { 0x1c, 0x3e, 0x7f, 0x7f, 0x7f, 0x3e, 0x1c, 0x00 }, /* 0x29 ● */
  { 0x1c, 0x22, 0x5d, 0x55, 0x5d, 0x22, 0x1c, 0x00 }, /* 0x2A ◎ */
  { 0x08, 0x14, 0x22, 0x41, 0x22, 0x14, 0x08, 0x00 }, /* 0x2B ◇ */
  { 0x08, 0x1c, 0x3e, 0x7f, 0x3e, 0x1c, 0x08, 0x00 }, /* 0x2C ◆ */
  { 0x7f, 0x41, 0x41, 0x41, 0x41, 0x41, 0x7f, 0x00 }, /* 0x2D □ */
  { 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00 }, /* 0x2E ■ */
  { 0x40, 0x70, 0x4c, 0x43, 0x4c, 0x70, 0x40, 0x00 }, /* 0x2F △ */
  { 0x40, 0x70, 0x7c, 0x7f, 0x7c, 0x70, 0x40, 0x00 }, /* 0x30 ▲ */
  { 0x01, 0x07, 0x19, 0x61, 0x19, 0x07, 0x01, 0x00 }, /* 0x31 ▽ */
  { 0x01, 0x07, 0x1f, 0x7f, 0x1f, 0x07, 0x01, 0x00 }, /* 0x32 ▼ */
  { 0x49, 0x22, 0x14, 0x49, 0x14, 0x22, 0x49, 0x00 }, /* 0x33 ※ */
  { 0x05, 0x05, 0x05, 0x7d, 0x05, 0x05, 0x05, 0x00 }, /* 0x34 〒 */
  { 0x08, 0x08, 0x08, 0x08, 0x2a, 0x1c, 0x08, 0x00 }, /* 0x35 → */
  { 0x08, 0x1c, 0x2a, 0x08, 0x08, 0x08, 0x08, 0x00 }, /* 0x36 ← */
  { 0x00, 0x04, 0x02, 0x7f, 0x02, 0x04, 0x00, 0x00 }, /* 0x37 ↑ */
  { 0x00, 0x10, 0x20, 0x7f, 0x20, 0x10, 0x00, 0x00 }, /* 0x38 ↓ */
  { 0x00, 0x3e, 0x41, 0x41, 0x41, 0x41, 0x3e, 0x00 }, /* 0x39 ０ */
  { 0x00, 0x00, 0x42, 0x7f, 0x40, 0x00, 0x00, 0x00 }, /* 0x3A １ */
  { 0x00, 0x62, 0x51, 0x51, 0x49, 0x49, 0x46, 0x00 }, /* 0x3B ２ */
  { 0x00, 0x22, 0x41, 0x49, 0x49, 0x49, 0x36, 0x00 }, /* 0x3C ３ */
  { 0x00, 0x30, 0x28, 0x24, 0x22, 0x7f, 0x20, 0x00 }, /* 0x3D ４ */
  { 0x00, 0x2f, 0x45, 0x45, 0x45, 0x45, 0x39, 0x00 }, /* 0x3E ５ */
  { 0x00, 0x3e, 0x49, 0x49, 0x49, 0x49, 0x32, 0x00 }, /* 0x3F ６ */
  { 0x00, 0x01, 0x01, 0x61, 0x19, 0x05, 0x03, 0x00 }, /* 0x40 ７ */
  { 0x00, 0x36, 0x49, 0x49, 0x49, 0x49, 0x36, 0x00 }, /* 0x41 ８ */
  { 0x00, 0x26, 0x49, 0x49, 0x49, 0x49, 0x3e, 0x00 }, /* 0x42 ９ */
  { 0x00, 0x20, 0x54, 0x7e, 0x34, 0x14, 0x60, 0x00 }, /* 0x43 ぁ */
  { 0x20, 0x52, 0x7f, 0x2a, 0x1a, 0x4a, 0x30, 0x00 }, /* 0x44 あ */
  { 0x00, 0x3c, 0x40, 0x20, 0x04, 0x18, 0x00, 0x00 }, /* 0x45 ぃ */
  { 0x1e, 0x20, 0x40, 0x20, 0x02, 0x04, 0x18, 0x00 }, /* 0x46 い */
  { 0x00, 0x10, 0x4a, 0x4a, 0x2a, 0x10, 0x00, 0x00 }, /* 0x47 ぅ */
  { 0x00, 0x08, 0x45, 0x45, 0x45, 0x25, 0x18, 0x00 }, /* 0x48 う */
  { 0x00, 0x48, 0x2a, 0x3a, 0x4a, 0x40, 0x00, 0x00 }, /* 0x49 ぇ */
  { 0x00, 0x44, 0x25, 0x15, 0x3d, 0x45, 0x40, 0x00 }, /* 0x4A え */
  { 0x00, 0x24, 0x7e, 0x14, 0x50, 0x24, 0x00, 0x00 }, /* 0x4B ぉ */
  { 0x22, 0x52, 0x7f, 0x0a, 0x48, 0x4a, 0x34, 0x00 }, /* 0x4C お */
  { 0x44, 0x34, 0x4f, 0x44, 0x38, 0x04, 0x18, 0x00 }, /* 0x4D か */
  { 0x44, 0x34, 0x4f, 0x44, 0x39, 0x04, 0x19, 0x00 }, /* 0x4E が */
  { 0x00, 0x2a, 0x5a, 0x4b, 0x4e, 0x5a, 0x08, 0x00 }, /* 0x4F き */
  { 0x00, 0x2a, 0x5a, 0x4b, 0x4e, 0x5b, 0x08, 0x00 }, /* 0x50 ぎ */
  { 0x00, 0x08, 0x14, 0x14, 0x22, 0x41, 0x00, 0x00 }, /* 0x51 く */
  { 0x00, 0x08, 0x14, 0x14, 0x22, 0x45, 0x04, 0x00 }, /* 0x52 ぐ */
  { 0x3f, 0x00, 0x04, 0x44, 0x3f, 0x04, 0x04, 0x00 }, /* 0x53 け */
  { 0x3f, 0x00, 0x04, 0x44, 0x3f, 0x04, 0x05, 0x00 }, /* 0x54 げ */
  { 0x00, 0x20, 0x52, 0x42, 0x42, 0x42, 0x40, 0x00 }, /* 0x55 こ */
  { 0x00, 0x20, 0x52, 0x42, 0x43, 0x42, 0x41, 0x00 }, /* 0x56 ご */
  { 0x00, 0x24, 0x54, 0x44, 0x47, 0x5c, 0x04, 0x00 }, /* 0x57 さ */
  { 0x00, 0x24, 0x54, 0x44, 0x47, 0x5c, 0x05, 0x00 }, /* 0x58 ざ */
  { 0x00, 0x00, 0x3f, 0x40, 0x40, 0x40, 0x20, 0x00 }, /* 0x59 し */
  { 0x00, 0x00, 0x3f, 0x40, 0x41, 0x40, 0x21, 0x00 }, /* 0x5A じ */
  { 0x02, 0x02, 0x0a, 0x56, 0x3f, 0x02, 0x02, 0x00 }, /* 0x5B す */
  { 0x02, 0x02, 0x0a, 0x56, 0x3f, 0x02, 0x03, 0x00 }, /* 0x5C ず */
  { 0x04, 0x04, 0x3f, 0x44, 0x54, 0x5f, 0x44, 0x00 }, /* 0x5D せ */
  { 0x04, 0x04, 0x3f, 0x44, 0x54, 0x5f, 0x45, 0x00 }, /* 0x5E ぜ */
  { 0x00, 0x08, 0x09, 0x3d, 0x4b, 0x49, 0x08, 0x00 }, /* 0x5F そ */
  { 0x00, 0x08, 0x09, 0x3d, 0x4b, 0x49, 0x0a, 0x00 }, /* 0x60 ぞ */
  { 0x42, 0x3a, 0x07, 0x22, 0x54, 0x44, 0x44, 0x00 }, /* 0x61 た */
  { 0x42, 0x3a, 0x07, 0x22, 0x55, 0x44, 0x45, 0x00 }, /* 0x62 だ */
  { 0x00, 0x02, 0x12, 0x4e, 0x4b, 0x4a, 0x32, 0x00 }, /* 0x63 ち */
  { 0x00, 0x02, 0x12, 0x4e, 0x4b, 0x4a, 0x33, 0x00 }, /* 0x64 ぢ */
  { 0x00, 0x10, 0x10, 0x48, 0x48, 0x30, 0x00, 0x00 }, /* 0x65 っ */
  { 0x04, 0x04, 0x02, 0x22, 0x22, 0x22, 0x1c, 0x00 }, /* 0x66 つ */
  { 0x04, 0x04, 0x02, 0x22, 0x23, 0x22, 0x1d, 0x00 }, /* 0x67 づ */
  { 0x00, 0x02, 0x02, 0x1a, 0x25, 0x43, 0x41, 0x00 }, /* 0x68 て */
  { 0x00, 0x02, 0x02, 0x1a, 0x25, 0x43, 0x45, 0x00 }, /* 0x69 で */
  { 0x00, 0x20, 0x57, 0x48, 0x48, 0x44, 0x44, 0x00 }, /* 0x6A と */
  { 0x00, 0x20, 0x57, 0x48, 0x49, 0x44, 0x45, 0x00 }, /* 0x6B ど */
  { 0x12, 0x0a, 0x27, 0x52, 0x50, 0x3a, 0x24, 0x00 }, /* 0x6C な */
  { 0x7f, 0x00, 0x20, 0x52, 0x42, 0x42, 0x40, 0x00 }, /* 0x6D に */
  { 0x30, 0x4e, 0x38, 0x54, 0x0f, 0x64, 0x78, 0x00 }, /* 0x6E ぬ */
  { 0x24, 0x14, 0x7f, 0x04, 0x22, 0x52, 0x3c, 0x00 }, /* 0x6F ね */
  { 0x18, 0x24, 0x12, 0x4e, 0x42, 0x24, 0x18, 0x00 }, /* 0x70 の */
  { 0x7f, 0x00, 0x24, 0x54, 0x54, 0x3f, 0x44, 0x00 }, /* 0x71 は */
  { 0x7f, 0x00, 0x24, 0x54, 0x54, 0x3f, 0x45, 0x00 }, /* 0x72 ば */
  { 0x7f, 0x00, 0x24, 0x54, 0x56, 0x3d, 0x46, 0x00 }, /* 0x73 ぱ */
  { 0x02, 0x3a, 0x47, 0x40, 0x41, 0x3e, 0x04, 0x00 }, /* 0x74 ひ */
  { 0x02, 0x3a, 0x47, 0x40, 0x41, 0x3e, 0x05, 0x00 }, /* 0x75 び */
  { 0x02, 0x3a, 0x47, 0x40, 0x43, 0x3d, 0x06, 0x00 }, /* 0x76 ぴ */
  { 0x40, 0x30, 0x40, 0x4d, 0x32, 0x10, 0x60, 0x00 }, /* 0x77 ふ */
  { 0x40, 0x30, 0x40, 0x4d, 0x32, 0x11, 0x61, 0x00 }, /* 0x78 ぶ */
  { 0x40, 0x30, 0x40, 0x4d, 0x32, 0x15, 0x62, 0x00 }, /* 0x79 ぷ */
  { 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00 }, /* 0x7A へ */
  { 0x08, 0x04, 0x02, 0x04, 0x09, 0x10, 0x11, 0x00 }, /* 0x7B べ */
  { 0x08, 0x04, 0x02, 0x04, 0x0a, 0x15, 0x12, 0x00 }, /* 0x7C ぺ */
  { 0x7f, 0x00, 0x6a, 0x6a, 0x7e, 0x2a, 0x4a, 0x00 }, /* 0x7D ほ */
  { 0x7f, 0x00, 0x6a, 0x6a, 0x7f, 0x2a, 0x4b, 0x00 }, /* 0x7E ぼ */
  { 0x7f, 0x00, 0x6a, 0x6a, 0x7e, 0x2d, 0x4a, 0x00 }, /* 0x7F ぽ */
  { 0x00, 0x6a, 0x6a, 0x6a, 0x7f, 0x2a, 0x4a, 0x00 }, /* 0x80 ま */
  { 0x30, 0x29, 0x1d, 0x4b, 0x48, 0x3c, 0x10, 0x00 }, /* 0x81 み */
  { 0x12, 0x2a, 0x7f, 0x42, 0x40, 0x42, 0x24, 0x00 }, /* 0x82 む */
  { 0x30, 0x4e, 0x38, 0x54, 0x0f, 0x44, 0x38, 0x00 }, /* 0x83 め */
  { 0x00, 0x0a, 0x3e, 0x4b, 0x4a, 0x4a, 0x30, 0x00 }, /* 0x84 も */
  { 0x00, 0x08, 0x0e, 0x38, 0x46, 0x14, 0x08, 0x00 }, /* 0x85 ゃ */
  { 0x04, 0x07, 0x1c, 0x62, 0x03, 0x0a, 0x04, 0x00 }, /* 0x86 や */
  { 0x00, 0x1c, 0x48, 0x3e, 0x24, 0x18, 0x00, 0x00 }, /* 0x87 ゅ */
  { 0x1e, 0x04, 0x52, 0x3f, 0x12, 0x12, 0x0c, 0x00 }, /* 0x88 ゆ */
  { 0x00, 0x20, 0x50, 0x50, 0x3e, 0x48, 0x00, 0x00 }, /* 0x89 ょ */
  { 0x00, 0x20, 0x50, 0x50, 0x3f, 0x24, 0x44, 0x00 }, /* 0x8A よ */
  { 0x00, 0x1c, 0x51, 0x49, 0x4a, 0x48, 0x30, 0x00 }, /* 0x8B ら */
  { 0x00, 0x0f, 0x42, 0x41, 0x21, 0x1e, 0x00, 0x00 }, /* 0x8C り */
  { 0x00, 0x10, 0x69, 0x6d, 0x4b, 0x49, 0x30, 0x00 }, /* 0x8D る */
  { 0x24, 0x14, 0x7f, 0x04, 0x02, 0x3e, 0x40, 0x00 }, /* 0x8E れ */
  { 0x00, 0x10, 0x49, 0x4d, 0x4b, 0x49, 0x30, 0x00 }, /* 0x8F ろ */
  { 0x00, 0x28, 0x18, 0x7e, 0x08, 0x44, 0x38, 0x00 }, /* 0x90 ゎ */
  { 0x24, 0x14, 0x7f, 0x04, 0x42, 0x42, 0x3c, 0x00 }, /* 0x91 わ */
  { 0x30, 0x49, 0x25, 0x1f, 0x24, 0x54, 0x38, 0x00 }, /* 0x92 ゐ */
  { 0x40, 0x28, 0x25, 0x57, 0x35, 0x28, 0x40, 0x00 }, /* 0x93 ゑ */
  { 0x10, 0x0a, 0x2e, 0x5b, 0x72, 0x4a, 0x48, 0x00 }, /* 0x94 を */
  { 0x40, 0x30, 0x0c, 0x33, 0x40, 0x40, 0x20, 0x00 }, /* 0x95 ん */
  { 0x00, 0x04, 0x44, 0x3c, 0x14, 0x0c, 0x00, 0x00 }, /* 0x96 ァ */
  { 0x00, 0x01, 0x41, 0x3d, 0x09, 0x05, 0x03, 0x00 }, /* 0x97 ア */
  { 0x00, 0x20, 0x20, 0x10, 0x78, 0x04, 0x00, 0x00 }, /* 0x98 ィ */
  { 0x00, 0x10, 0x10, 0x08, 0x7c, 0x02, 0x01, 0x00 }, /* 0x99 イ */
  { 0x00, 0x18, 0x48, 0x4c, 0x28, 0x18, 0x00, 0x00 }, /* 0x9A ゥ */
  { 0x00, 0x06, 0x42, 0x43, 0x22, 0x12, 0x0e, 0x00 }, /* 0x9B ウ */
  { 0x00, 0x40, 0x48, 0x78, 0x48, 0x40, 0x00, 0x00 }, /* 0x9C ェ */
  { 0x20, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x20, 0x00 }, /* 0x9D エ */
  { 0x00, 0x28, 0x28, 0x58, 0x7c, 0x08, 0x00, 0x00 }, /* 0x9E ォ */
  { 0x22, 0x22, 0x12, 0x4a, 0x7f, 0x02, 0x02, 0x00 }, /* 0x9F オ */
  { 0x00, 0x42, 0x22, 0x1f, 0x02, 0x42, 0x7e, 0x00 }, /* 0xA0 カ */
  { 0x00, 0x42, 0x22, 0x1f, 0x02, 0x42, 0x7f, 0x00 }, /* 0xA1 ガ */
  { 0x00, 0x12, 0x12, 0x1f, 0x72, 0x12, 0x10, 0x00 }, /* 0xA2 キ */
  { 0x00, 0x12, 0x12, 0x1f, 0x72, 0x13, 0x10, 0x00 }, /* 0xA3 ギ */
  { 0x00, 0x08, 0x44, 0x43, 0x22, 0x12, 0x0e, 0x00 }, /* 0xA4 ク */
  { 0x00, 0x08, 0x44, 0x43, 0x22, 0x12, 0x0f, 0x00 }, /* 0xA5 グ */
  { 0x08, 0x07, 0x42, 0x22, 0x1e, 0x02, 0x02, 0x00 }, /* 0xA6 ケ */
  { 0x08, 0x07, 0x42, 0x22, 0x1f, 0x02, 0x03, 0x00 }, /* 0xA7 ゲ */
  { 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x00 }, /* 0xA8 コ */
  { 0x00, 0x42, 0x42, 0x42, 0x43, 0x42, 0x7f, 0x00 }, /* 0xA9 ゴ */
  { 0x02, 0x02, 0x4f, 0x42, 0x22, 0x1f, 0x02, 0x00 }, /* 0xAA サ */
  { 0x02, 0x02, 0x4f, 0x42, 0x23, 0x1e, 0x03, 0x00 }, /* 0xAB ザ */
  { 0x00, 0x45, 0x4a, 0x40, 0x20, 0x10, 0x0c, 0x00 }, /* 0xAC シ */
  { 0x00, 0x45, 0x4a, 0x40, 0x21, 0x10, 0x0d, 0x00 }, /* 0xAD ジ */
  { 0x40, 0x42, 0x22, 0x22, 0x1a, 0x26, 0x40, 0x00 }, /* 0xAE ス */
  { 0x40, 0x42, 0x22, 0x22, 0x1b, 0x26, 0x41, 0x00 }, /* 0xAF ズ */
  { 0x04, 0x04, 0x3f, 0x44, 0x44, 0x54, 0x4c, 0x00 }, /* 0xB0 セ */
  { 0x04, 0x04, 0x3f, 0x44, 0x45, 0x54, 0x4d, 0x00 }, /* 0xB1 ゼ */
  { 0x00, 0x01, 0x46, 0x40, 0x20, 0x10, 0x0f, 0x00 }, /* 0xB2 ソ */
  { 0x00, 0x01, 0x46, 0x40, 0x20, 0x11, 0x0f, 0x00 }, /* 0xB3 ゾ */
  { 0x00, 0x08, 0x44, 0x4b, 0x2a, 0x12, 0x0e, 0x00 }, /* 0xB4 タ */
  { 0x00, 0x08, 0x44, 0x4b, 0x2a, 0x12, 0x0f, 0x00 }, /* 0xB5 ダ */
  { 0x08, 0x0a, 0x4a, 0x3e, 0x09, 0x09, 0x08, 0x00 }, /* 0xB6 チ */
  { 0x08, 0x0a, 0x4a, 0x3e, 0x09, 0x08, 0x09, 0x00 }, /* 0xB7 ヂ */
  { 0x00, 0x18, 0x40, 0x58, 0x20, 0x18, 0x00, 0x00 }, /* 0xB8 ッ */
  { 0x02, 0x0c, 0x42, 0x4c, 0x20, 0x10, 0x0e, 0x00 }, /* 0xB9 ツ */
  { 0x02, 0x0c, 0x42, 0x4c, 0x21, 0x10, 0x0d, 0x00 }, /* 0xBA ヅ */
  { 0x04, 0x05, 0x45, 0x3d, 0x05, 0x05, 0x04, 0x00 }, /* 0xBB テ */
  { 0x04, 0x05, 0x45, 0x3d, 0x05, 0x04, 0x05, 0x00 }, /* 0xBC デ */
  { 0x00, 0x00, 0x7f, 0x08, 0x08, 0x10, 0x00, 0x00 }, /* 0xBD ト */
  { 0x00, 0x00, 0x7f, 0x08, 0x09, 0x10, 0x01, 0x00 }, /* 0xBE ド */
  { 0x04, 0x44, 0x24, 0x1f, 0x04, 0x04, 0x04, 0x00 }, /* 0xBF ナ */
  { 0x20, 0x22, 0x22, 0x22, 0x22, 0x22, 0x20, 0x00 }, /* 0xC0 ニ */
  { 0x40, 0x41, 0x25, 0x15, 0x19, 0x27, 0x00, 0x00 }, /* 0xC1 ヌ */
  { 0x20, 0x22, 0x12, 0x7b, 0x06, 0x12, 0x20, 0x00 }, /* 0xC2 ネ */
  { 0x40, 0x40, 0x20, 0x10, 0x08, 0x07, 0x00, 0x00 }, /* 0xC3 ノ */
  { 0x40, 0x30, 0x0e, 0x00, 0x02, 0x0c, 0x70, 0x00 }, /* 0xC4 ハ */
  { 0x40, 0x30, 0x0e, 0x00, 0x02, 0x0d, 0x71, 0x00 }, /* 0xC5 バ */
  { 0x40, 0x30, 0x0e, 0x00, 0x02, 0x0d, 0x72, 0x00 }, /* 0xC6 パ */
  { 0x00, 0x3f, 0x48, 0x48, 0x48, 0x44, 0x44, 0x00 }, /* 0xC7 ヒ */
  { 0x00, 0x3f, 0x48, 0x48, 0x49, 0x44, 0x45, 0x00 }, /* 0xC8 ビ */
  { 0x00, 0x3f, 0x48, 0x48, 0x4a, 0x45, 0x46, 0x00 }, /* 0xC9 ピ */
  { 0x00, 0x02, 0x42, 0x42, 0x22, 0x12, 0x0e, 0x00 }, /* 0xCA フ */
  { 0x00, 0x02, 0x42, 0x42, 0x23, 0x12, 0x0f, 0x00 }, /* 0xCB ブ */
  { 0x00, 0x02, 0x42, 0x42, 0x22, 0x15, 0x0e, 0x00 }, /* 0xCC プ */
  { 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00 }, /* 0xCD ヘ */
  { 0x08, 0x04, 0x02, 0x04, 0x09, 0x10, 0x21, 0x00 }, /* 0xCE ベ */
  { 0x08, 0x04, 0x02, 0x04, 0x0a, 0x15, 0x22, 0x00 }, /* 0xCF ペ */
  { 0x24, 0x14, 0x44, 0x7f, 0x04, 0x14, 0x24, 0x00 }, /* 0xD0 ホ */
  { 0x24, 0x14, 0x44, 0x7f, 0x05, 0x14, 0x25, 0x00 }, /* 0xD1 ボ */
  { 0x24, 0x14, 0x44, 0x7f, 0x06, 0x15, 0x22, 0x00 }, /* 0xD2 ポ */
  { 0x02, 0x02, 0x12, 0x22, 0x52, 0x0a, 0x06, 0x00 }, /* 0xD3 マ */
  { 0x00, 0x21, 0x25, 0x29, 0x4a, 0x42, 0x00, 0x00 }, /* 0xD4 ミ */
  { 0x40, 0x70, 0x4c, 0x43, 0x50, 0x20, 0x40, 0x00 }, /* 0xD5 ム */
  { 0x40, 0x44, 0x24, 0x14, 0x08, 0x37, 0x00, 0x00 }, /* 0xD6 メ */
  { 0x00, 0x08, 0x09, 0x3f, 0x49, 0x49, 0x48, 0x00 }, /* 0xD7 モ */
  { 0x00, 0x10, 0x1c, 0x68, 0x08, 0x18, 0x00, 0x00 }, /* 0xD8 ャ */
  { 0x04, 0x04, 0x0f, 0x74, 0x02, 0x0a, 0x06, 0x00 }, /* 0xD9 ヤ */
  { 0x00, 0x40, 0x48, 0x48, 0x78, 0x40, 0x00, 0x00 }, /* 0xDA ュ */
  { 0x20, 0x22, 0x22, 0x22, 0x3e, 0x20, 0x20, 0x00 }, /* 0xDB ユ */
  { 0x00, 0x00, 0x44, 0x54, 0x54, 0x7c, 0x00, 0x00 }, /* 0xDC ョ */
  { 0x00, 0x42, 0x4a, 0x4a, 0x4a, 0x4a, 0x7e, 0x00 }, /* 0xDD ヨ */
  { 0x00, 0x04, 0x45, 0x45, 0x25, 0x15, 0x0c, 0x00 }, /* 0xDE ラ */
  { 0x00, 0x0f, 0x40, 0x40, 0x20, 0x1f, 0x00, 0x00 }, /* 0xDF リ */
  { 0x40, 0x20, 0x1e, 0x00, 0x7f, 0x20, 0x10, 0x00 }, /* 0xE0 ル */
  { 0x00, 0x00, 0x7f, 0x40, 0x20, 0x10, 0x08, 0x00 }, /* 0xE1 レ */
  { 0x00, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x00 }, /* 0xE2 ロ */
  { 0x00, 0x0c, 0x44, 0x44, 0x24, 0x1c, 0x00, 0x00 }, /* 0xE3 ヮ */
  { 0x00, 0x06, 0x42, 0x42, 0x22, 0x12, 0x0e, 0x00 }, /* 0xE4 ワ */
  { 0x10, 0x12, 0x1e, 0x12, 0x12, 0x7f, 0x12, 0x00 }, /* 0xE5 ヰ */
  { 0x20, 0x22, 0x22, 0x3a, 0x26, 0x22, 0x20, 0x00 }, /* 0xE6 ヱ */
  { 0x00, 0x01, 0x45, 0x45, 0x25, 0x15, 0x0f, 0x00 }, /* 0xE7 ヲ */
  { 0x00, 0x41, 0x42, 0x40, 0x20, 0x10, 0x0c, 0x00 }, /* 0xE8 ン */
  { 0x00, 0x06, 0x42, 0x43, 0x22, 0x12, 0x0f, 0x00 }, /* 0xE9 ヴ */
  { 0x00, 0x48, 0x28, 0x1c, 0x48, 0x78, 0x00, 0x00 }, /* 0xEA ヵ */
  { 0x00, 0x10, 0x0c, 0x48, 0x38, 0x08, 0x00, 0x00 }, /* 0xEB ヶ */
  { 0x08, 0x04, 0x04, 0x08, 0x10, 0x10, 0x08, 0x00 }, /* 0xEC 〜 */
  { 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00 }, /* 0xED … */
  { 0x04, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 }, /* 0xEE ー */
  { 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08 }, /* 0xEF ― */
};

#define MISAKI_FONT_F1_H
PROGMEM const uint8_t misaki_font_f1[ MISAKI_FONT_F1_SIZE + 1 ][ MISAKI_FONT_F1_W ] =
{
  { 0x00, 0x00, 0x00 }, /* 0x00 */
  { 0x00, 0x2f, 0x00 }, /* 0x01 ! */
  { 0x03, 0x00, 0x03 }, /* 0x02 " */
  { 0x3f, 0x12, 0x3f }, /* 0x03 # */
  { 0x16, 0x3f, 0x1a }, /* 0x04 $ */
  { 0x12, 0x08, 0x24 }, /* 0x05 % */
  { 0x32, 0x3d, 0x2a }, /* 0x06 & */
  { 0x02, 0x01, 0x00 }, /* 0x07 ' */
  { 0x00, 0x3e, 0x41 }, /* 0x08 ( */
  { 0x41, 0x3e, 0x00 }, /* 0x09 ) */
  { 0x0a, 0x07, 0x0a }, /* 0x0A * */
  { 0x08, 0x3e, 0x08 }, /* 0x0B + */
  { 0x40, 0x20, 0x00 }, /* 0x0C , */
  { 0x08, 0x08, 0x08 }, /* 0x0D - */
  { 0x00, 0x20, 0x00 }, /* 0x0E . */
  { 0x10, 0x08, 0x04 }, /* 0x0F / */
  { 0x1c, 0x2a, 0x1c }, /* 0x10 0 */
  { 0x24, 0x3e, 0x20 }, /* 0x11 1 */
  { 0x32, 0x2a, 0x24 }, /* 0x12 2 */
  { 0x22, 0x2a, 0x14 }, /* 0x13 3 */
  { 0x18, 0x14, 0x3e }, /* 0x14 4 */
  { 0x2e, 0x2a, 0x12 }, /* 0x15 5 */
  { 0x1c, 0x2a, 0x12 }, /* 0x16 6 */
  { 0x02, 0x3a, 0x06 }, /* 0x17 7 */
  { 0x14, 0x2a, 0x14 }, /* 0x18 8 */
  { 0x24, 0x2a, 0x1c }, /* 0x19 9 */
  { 0x00, 0x24, 0x00 }, /* 0x1A : */
  { 0x40, 0x24, 0x00 }, /* 0x1B ; */
  { 0x08, 0x14, 0x22 }, /* 0x1C < */
  { 0x14, 0x14, 0x14 }, /* 0x1D = */
  { 0x22, 0x14, 0x08 }, /* 0x1E > */
  { 0x02, 0x29, 0x06 }, /* 0x1F ? */
  { 0x12, 0x29, 0x1e }, /* 0x20 @ */
  { 0x3e, 0x09, 0x3e }, /* 0x21 A */
  { 0x3f, 0x25, 0x1a }, /* 0x22 B */
  { 0x1e, 0x21, 0x21 }, /* 0x23 C */
  { 0x3f, 0x21, 0x1e }, /* 0x24 D */
  { 0x3f, 0x25, 0x21 }, /* 0x25 E */
  { 0x3f, 0x05, 0x01 }, /* 0x26 F */
  { 0x1e, 0x21, 0x39 }, /* 0x27 G */
  { 0x3f, 0x08, 0x3f }, /* 0x28 H */
  { 0x21, 0x3f, 0x21 }, /* 0x29 I */
  { 0x10, 0x20, 0x1f }, /* 0x2A J */
  { 0x3f, 0x04, 0x3b }, /* 0x2B K */
  { 0x3f, 0x20, 0x20 }, /* 0x2C L */
  { 0x3f, 0x06, 0x3f }, /* 0x2D M */
  { 0x3f, 0x01, 0x3e }, /* 0x2E N */
  { 0x1e, 0x21, 0x1e }, /* 0x2F O */
  { 0x3f, 0x09, 0x06 }, /* 0x30 P */
  { 0x1e, 0x21, 0x5e }, /* 0x31 Q */
  { 0x3f, 0x09, 0x36 }, /* 0x32 R */
  { 0x22, 0x25, 0x19 }, /* 0x33 S */
  { 0x01, 0x3f, 0x01 }, /* 0x34 T */
  { 0x3f, 0x20, 0x3f }, /* 0x35 U */
  { 0x3f, 0x10, 0x0f }, /* 0x36 V */
  { 0x3f, 0x18, 0x3f }, /* 0x37 W */
  { 0x33, 0x0c, 0x33 }, /* 0x38 X */
  { 0x03, 0x3c, 0x03 }, /* 0x39 Y */
  { 0x31, 0x2d, 0x23 }, /* 0x3A Z */
  { 0x00, 0x7f, 0x41 }, /* 0x3B [ */
  { 0x15, 0x3e, 0x15 }, /* 0x3C \ */
  { 0x41, 0x7f, 0x00 }, /* 0x3D ] */
  { 0x02, 0x01, 0x02 }, /* 0x3E ^ */
  { 0x40, 0x40, 0x40 }, /* 0x3F _ */
  { 0x00, 0x01, 0x02 }, /* 0x40 ` */
  { 0x18, 0x24, 0x3c }, /* 0x41 a */
  { 0x3f, 0x24, 0x18 }, /* 0x42 b */
  { 0x18, 0x24, 0x24 }, /* 0x43 c */
  { 0x18, 0x24, 0x3f }, /* 0x44 d */
  { 0x18, 0x2c, 0x2c }, /* 0x45 e */
  { 0x04, 0x3f, 0x05 }, /* 0x46 f */
  { 0x48, 0x54, 0x3c }, /* 0x47 g */
  { 0x3f, 0x04, 0x38 }, /* 0x48 h */
  { 0x00, 0x3d, 0x00 }, /* 0x49 i */
  { 0x40, 0x3d, 0x00 }, /* 0x4A j */
  { 0x3f, 0x08, 0x34 }, /* 0x4B k */
  { 0x01, 0x3f, 0x00 }, /* 0x4C l */
  { 0x3c, 0x1c, 0x38 }, /* 0x4D m */
  { 0x3c, 0x04, 0x38 }, /* 0x4E n */
  { 0x18, 0x24, 0x18 }, /* 0x4F o */
  { 0x7c, 0x24, 0x18 }, /* 0x50 p */
  { 0x18, 0x24, 0x7c }, /* 0x51 q */
  { 0x3c, 0x08, 0x04 }, /* 0x52 r */
  { 0x28, 0x3c, 0x14 }, /* 0x53 s */
  { 0x04, 0x3e, 0x24 }, /* 0x54 t */
  { 0x3c, 0x20, 0x3c }, /* 0x55 u */
  { 0x3c, 0x10, 0x0c }, /* 0x56 v */
  { 0x3c, 0x30, 0x3c }, /* 0x57 w */
  { 0x24, 0x18, 0x24 }, /* 0x58 x */
  { 0x4c, 0x50, 0x3c }, /* 0x59 y */
  { 0x24, 0x34, 0x2c }, /* 0x5A z */
  { 0x08, 0x36, 0x41 }, /* 0x5B { */
  { 0x00, 0x7f, 0x00 }, /* 0x5C | */
  { 0x41, 0x36, 0x08 }, /* 0x5D } */
  { 0x01, 0x01, 0x01 }, /* 0x5E ~ */
  { 0x10, 0x28, 0x10 }, /* 0x5F ｡ */
  { 0x1f, 0x01, 0x01 }, /* 0x60 ｢ */
  { 0x20, 0x20, 0x3e }, /* 0x61 ｣ */
  { 0x10, 0x20, 0x00 }, /* 0x62 ､ */
  { 0x00, 0x08, 0x00 }, /* 0x63 ･ */
  { 0x25, 0x15, 0x0f }, /* 0x64 ｦ */
  { 0x24, 0x1c, 0x0c }, /* 0x65 ｧ */
  { 0x10, 0x38, 0x04 }, /* 0x66 ｨ */
  { 0x18, 0x0c, 0x38 }, /* 0x67 ｩ */
  { 0x28, 0x38, 0x28 }, /* 0x68 ｪ */
  { 0x28, 0x18, 0x3c }, /* 0x69 ｫ */
  { 0x08, 0x3c, 0x18 }, /* 0x6A ｬ */
  { 0x28, 0x38, 0x20 }, /* 0x6B ｭ */
  { 0x24, 0x2c, 0x3c }, /* 0x6C ｮ */
  { 0x2c, 0x2c, 0x1c }, /* 0x6D ｯ */
  { 0x04, 0x08, 0x08 }, /* 0x6E ｰ */
  { 0x21, 0x1d, 0x07 }, /* 0x6F ｱ */
  { 0x08, 0x3c, 0x03 }, /* 0x70 ｲ */
  { 0x06, 0x23, 0x1e }, /* 0x71 ｳ */
  { 0x22, 0x3e, 0x22 }, /* 0x72 ｴ */
  { 0x12, 0x0a, 0x3f }, /* 0x73 ｵ */
  { 0x32, 0x0f, 0x3e }, /* 0x74 ｶ */
  { 0x0a, 0x3f, 0x0a }, /* 0x75 ｷ */
  { 0x24, 0x13, 0x0e }, /* 0x76 ｸ */
  { 0x27, 0x1e, 0x02 }, /* 0x77 ｹ */
  { 0x22, 0x22, 0x3e }, /* 0x78 ｺ */
  { 0x27, 0x12, 0x0f }, /* 0x79 ｻ */
  { 0x25, 0x25, 0x10 }, /* 0x7A ｼ */
  { 0x21, 0x19, 0x27 }, /* 0x7B ｽ */
  { 0x3f, 0x22, 0x2e }, /* 0x7C ｾ */
  { 0x21, 0x16, 0x0f }, /* 0x7D ｿ */
  { 0x24, 0x1b, 0x0e }, /* 0x7E ﾀ */
  { 0x25, 0x1f, 0x05 }, /* 0x7F ﾁ */
  { 0x26, 0x26, 0x1e }, /* 0x80 ﾂ */
  { 0x25, 0x1d, 0x05 }, /* 0x81 ﾃ */
  { 0x3f, 0x04, 0x08 }, /* 0x82 ﾄ */
  { 0x24, 0x1f, 0x04 }, /* 0x83 ﾅ */
  { 0x20, 0x22, 0x22 }, /* 0x84 ﾆ */
  { 0x25, 0x19, 0x27 }, /* 0x85 ﾇ */
  { 0x12, 0x3b, 0x16 }, /* 0x86 ﾈ */
  { 0x20, 0x10, 0x0f }, /* 0x87 ﾉ */
  { 0x3c, 0x01, 0x3e }, /* 0x88 ﾊ */
  { 0x1f, 0x24, 0x24 }, /* 0x89 ﾋ */
  { 0x21, 0x11, 0x0f }, /* 0x8A ﾌ */
  { 0x0c, 0x03, 0x1c }, /* 0x8B ﾍ */
  { 0x1a, 0x3f, 0x1a }, /* 0x8C ﾎ */
  { 0x09, 0x19, 0x27 }, /* 0x8D ﾏ */
  { 0x22, 0x2a, 0x2a }, /* 0x8E ﾐ */
  { 0x38, 0x27, 0x30 }, /* 0x8F ﾑ */
  { 0x32, 0x0c, 0x13 }, /* 0x90 ﾒ */
  { 0x05, 0x3f, 0x25 }, /* 0x91 ﾓ */
  { 0x02, 0x3f, 0x0e }, /* 0x92 ﾔ */
  { 0x21, 0x3f, 0x20 }, /* 0x93 ﾕ */
  { 0x25, 0x25, 0x3f }, /* 0x94 ﾖ */
  { 0x25, 0x25, 0x1d }, /* 0x95 ﾗ */
  { 0x07, 0x20, 0x1f }, /* 0x96 ﾘ */
  { 0x3c, 0x3f, 0x20 }, /* 0x97 ﾙ */
  { 0x3f, 0x20, 0x10 }, /* 0x98 ﾚ */
  { 0x3e, 0x22, 0x3e }, /* 0x99 ﾛ */
  { 0x23, 0x11, 0x0f }, /* 0x9A ﾜ */
  { 0x21, 0x21, 0x18 }, /* 0x9B ﾝ */
  { 0x01, 0x00, 0x01 }, /* 0x9C ﾞ */
  { 0x02, 0x05, 0x02 }, /* 0x9D ﾟ */
};
#define MISAKI_FONT_F2_H
PROGMEM const uint8_t misaki_font_f2[ MISAKI_FONT_F2_SIZE + 1 ][ MISAKI_FONT_F2_W ] =
{
  { 0x75, 0x40, 0x77, 0x55, 0x75, 0x77, 0x40 }, /* 0x00 温 */
  { 0x40, 0x3e, 0x4a, 0x5e, 0x2b, 0x5e, 0x4a }, /* 0x01 度 */
  { 0x6b, 0x62, 0x7f, 0x35, 0x2f, 0x35, 0x7f }, /* 0x02 調 */
  { 0x7c, 0x5b, 0x5e, 0x24, 0x7b, 0x0e, 0x3a }, /* 0x03 節 */
  { 0x04, 0x7e, 0x01, 0x7e, 0x4a, 0x5e, 0x69 }, /* 0x04 低 */
  { 0x06, 0x3a, 0x2f, 0x3f, 0x6b, 0x7e, 0x46 }, /* 0x05 電 */
  { 0x40, 0x3f, 0x41, 0x49, 0x7f, 0x49, 0x41 }, /* 0x06 圧 */
  { 0x02, 0x62, 0x6b, 0x6b, 0x6b, 0x62, 0x02 }, /* 0x07 言 */
  { 0x6a, 0x6b, 0x14, 0x7d, 0x57, 0x7d, 0x10 }, /* 0x08 語 */
  { 0x41, 0x3f, 0x55, 0x55, 0x3d, 0x57, 0x51 }, /* 0x09 戻 */
  { 0x21, 0x3f, 0x2d, 0x7f, 0x2a, 0x12, 0x2e }, /* 0x0A 取 */
  { 0x0a, 0x77, 0x5a, 0x50, 0x5a, 0x77, 0x0a }, /* 0x0B 替 */
  { 0x20, 0x24, 0x13, 0x7d, 0x55, 0x53, 0x70 }, /* 0x0C 名 */
  { 0x7a, 0x2a, 0x7b, 0x02, 0x1a, 0x43, 0x7a }, /* 0x0D 前 */
  { 0x4a, 0x52, 0x5e, 0x2b, 0x5e, 0x42, 0x4a }, /* 0x0E 変 */
  { 0x41, 0x5f, 0x35, 0x3f, 0x55, 0x5f, 0x41 }, /* 0x0F 更 */
  { 0x7d, 0x14, 0x57, 0x7d, 0x0e, 0x40, 0x7f }, /* 0x10 削 */
  { 0x7f, 0x1b, 0x54, 0x16, 0x7d, 0x16, 0x54 }, /* 0x11 除 */
  { 0x49, 0x3a, 0x40, 0x7e, 0x57, 0x56, 0x76 }, /* 0x12 追 */
  { 0x42, 0x3f, 0x42, 0x7e, 0x7e, 0x42, 0x7e }, /* 0x13 加 */
  { 0x04, 0x7e, 0x51, 0x37, 0x7d, 0x37, 0x50 }, /* 0x14 保 */
  { 0x12, 0x7a, 0x17, 0x52, 0x76, 0x1e, 0x12 }, /* 0x15 存 */
  { 0x7f, 0x55, 0x7f, 0x14, 0x5d, 0x7f, 0x55 }, /* 0x16 睡 */
  { 0x7f, 0x55, 0x7f, 0x7f, 0x55, 0x3d, 0x57 }, /* 0x17 眠 */
  { 0x7f, 0x55, 0x37, 0x78, 0x17, 0x45, 0x7f }, /* 0x18 閉 */
  { 0x7f, 0x2b, 0x7b, 0x28, 0x7b, 0x2b, 0x7f }, /* 0x19 開 */
  { 0x1e, 0x12, 0x12, 0x7f, 0x12, 0x12, 0x1e }, /* 0x1A 中 */
  { 0x7f, 0x41, 0x6b, 0x7f, 0x6b, 0x51, 0x7f }, /* 0x1B 国 */
  { 0x52, 0x5a, 0x57, 0x3a, 0x57, 0x5a, 0x52 }, /* 0x1C 英 */
  { 0x00, 0x7f, 0x49, 0x49, 0x49, 0x49, 0x7f }, /* 0x1D 日 */
  { 0x22, 0x12, 0x2a, 0x7f, 0x2a, 0x12, 0x22 }, /* 0x1E 本 */
  { 0x16, 0x6a, 0x5e, 0x73, 0x56, 0x62, 0x16 }, /* 0x1F 密 */
  { 0x09, 0x37, 0x31, 0x5f, 0x15, 0x5f, 0x75 }, /* 0x20 碼 */
};
/*
  プリセット
  温度調節
  タイマー
  コントロール
  スクリーン
  ブザー
  低電圧アラーム
  言語
  戻る
  取り替える
  キャリブレーション
  名前を変更
  削除
  追加
  保存
  デフォルト
  睡眠
  ブースト
  保存
  睡眠
  閉じる
  ブースト
  保存
  ダイレクト
  PID
  ビッグ
  ニュース
  閉じる
  開く
  いいえ、
  はい、
  中国語
  英語
  いいえ、
  はい、
  メインスクリーン
  フリップ
  保存
  アバウト
  日本語

  汉字转换表:温度調節低電圧言語戻取替名前変更削除追加保存睡眠閉開中国英日本密碼
*/
const char JP_0[] PROGMEM  = { 0xf0, 0xcc, 0xdf, 0xb0, 0xb8, 0xbd, };
const char JP_1[] PROGMEM  = { 0xf2, 0x00, 0x01, 0x02, 0x03, };
const char JP_2[] PROGMEM  = { 0xf0, 0xb4, 0x99, 0xd3, 0xee, };
const char JP_3[] PROGMEM  = { 0xf0, 0xa8, 0xe8, 0xbd, 0xe2, 0xee, 0xe0, };
const char JP_4[] PROGMEM  = { 0xf0, 0xae, 0xa4, 0xdf, 0xee, 0xe8, };
const char JP_5[] PROGMEM  = { 0xf0, 0xcb, 0xab, 0xee, };
const char JP_6[] PROGMEM  = { 0xf2, 0x04, 0x05, 0x06, 0xf0, 0x97, 0xde, 0xee, 0xd5, };
const char JP_7[] PROGMEM  = { 0xf2, 0x07, 0x08, };
const char JP_8[] PROGMEM  = { 0xf2, 0x09, 0xf0, 0x8d, };
const char JP_9[] PROGMEM  = { 0xf2, 0x0a, 0xf0, 0x8c, 0xf2, 0x0b, 0xf0, 0x4a, 0x8d, };
const char JP_10[] PROGMEM = { 0xf0, 0xa2, 0xd8, 0xdf, 0xcb, 0xe1, 0xee, 0xac, 0xdc, 0xe8, };
const char JP_11[] PROGMEM = { 0xf2, 0x0c, 0x0d, 0xf0, 0x94, 0xf2, 0x0e, 0x0f, };
const char JP_12[] PROGMEM = { 0xf2, 0x10, 0x11, };
const char JP_13[] PROGMEM = { 0xf2, 0x12, 0x13, };
const char JP_14[] PROGMEM = { 0xf2, 0x14, 0x15, };
const char JP_15[] PROGMEM = { 0xf0, 0xbc, 0xca, 0x9e, 0xe0, 0xbd, };
const char JP_16[] PROGMEM = { 0xf2, 0x16, 0x17, };
const char JP_17[] PROGMEM = { 0xf0, 0xcb, 0xee, 0xae, 0xbd, };
const char JP_18[] PROGMEM = { 0xf2, 0x14, 0x15, };
const char JP_19[] PROGMEM = { 0xf2, 0x16, 0x17, };
const char JP_20[] PROGMEM = { 0xf2, 0x18, 0xf0, 0x5a, 0x8d, };
const char JP_21[] PROGMEM = { 0xf0, 0xcb, 0xee, 0xae, 0xbd, };
const char JP_22[] PROGMEM = { 0xf2, 0x14, 0x15, };
const char JP_23[] PROGMEM = { 0xf0, 0xb5, 0x99, 0xe1, 0xa4, 0xbd, };
const char JP_24[] PROGMEM = { 0xf1, 0x30, 0x29, 0x24, };
const char JP_25[] PROGMEM = { 0xf0, 0xc8, 0xb8, 0xa5, };
const char JP_26[] PROGMEM = { 0xf0, 0xc0, 0xda, 0xee, 0xae, };
const char JP_27[] PROGMEM = { 0xf2, 0x18, 0xf0, 0x5a, 0x8d, };
const char JP_28[] PROGMEM = { 0xf2, 0x19, 0xf0, 0x51, };
const char JP_29[] PROGMEM = { 0xf0, 0x46, 0x46, 0x4a, 0x01, };
const char JP_30[] PROGMEM = { 0xf0, 0x71, 0x46, 0x01, };
const char JP_31[] PROGMEM = { 0xf2, 0x1a, 0x1b, 0x08, };
const char JP_32[] PROGMEM = { 0xf2, 0x1c, 0x08, };
const char JP_33[] PROGMEM = { 0xf0, 0x46, 0x46, 0x4a, 0x01, };
const char JP_34[] PROGMEM = { 0xf0, 0x71, 0x46, 0x01, };
const char JP_35[] PROGMEM = { 0xf0, 0xd6, 0x99, 0xe8, 0xae, 0xa4, 0xdf, 0xee, 0xe8, };
const char JP_36[] PROGMEM = { 0xf0, 0xca, 0xdf, 0xb8, 0xcc, };
const char JP_37[] PROGMEM = { 0xf2, 0x14, 0x15, };
const char JP_38[] PROGMEM = { 0xf0, 0x97, 0xc5, 0x9b, 0xbd, };
const char JP_39[] PROGMEM = { 0xf2, 0x1d, 0x1e, 0x08, };
const char JP_40[] PROGMEM = { 0xf2, 0x1f, 0x20, }; //密码

const char *const JP_table[] = {JP_0, JP_1, JP_2, JP_3, JP_4, JP_5, JP_6, JP_40, JP_7, JP_38, JP_8, JP_9, JP_10, JP_11, JP_12, JP_13, JP_14, JP_15, JP_16, JP_17, JP_18, JP_19, JP_20, JP_21, JP_22, JP_23, JP_24, JP_25, JP_26, JP_27, JP_28, JP_29, JP_30, JP_31, JP_32, JP_39, JP_35, JP_36, JP_37,};
const char JP_Length_table[] PROGMEM = {6, 5, 5, 7, 6, 4, 9, 3, 3 , 5, 4, 9, 10, 8, 3, 3, 3, 6, 3, 5, 3, 3, 5, 5, 3, 6, 4, 4, 5, 5, 4, 5, 4, 4, 3, 4,  9, 5, 3,};

bool lastbutton;
#include <Arduboy2.h>  //注意 这里使用被阉割的图形库，只有绘图功能，并非通用的版本
Arduboy2 arduboy;

#include <EEPROM.h>
#include <PID_v1.h>
#include <avr/sleep.h>

// Firmware version
#define VERSION       "v1.8t1"

// Type of rotary encoder
#define ROTARY_TYPE   1         // 0: 2 increments/step; 1: 4 increments/step

// Pins
#define SENSOR_PIN    A0        // temperature sense
#define VIN_PIN       A1        // input voltage sense
#define BUZZER_PIN     5        // buzzer
#define BUTTON_PIN     6        // rotary encoder switch
#define ROTARY_1_PIN   7        // rotary encoder 1
#define ROTARY_2_PIN   8        // rotary encoder 2
#define CONTROL_PIN    9        // heater MOSFET PWM control
#define SWITCH_PIN    10        // handle vibration switch

// Default temperature control values (recommended soldering temperature: 300-380°C)
#define ChipTempCalVal 335  //芯片内部温度读取校准值 -->可以根据实际情况修改，不同机器情况不同，通常误差在10°C内
#define TEMP_MIN      150       // min selectable temperature
#define TEMP_MAX      400       // max selectable temperature
#define TEMP_DEFAULT  320       // default start setpoint
#define TEMP_SLEEP    150       // temperature in sleep mode
#define TEMP_BOOST     60       // temperature increase in boost mode
#define TEMP_STEP      10       // rotary encoder temp change steps

// Default tip temperature calibration values
#define TEMP200       216       // temperature at ADC = 200
#define TEMP280       308       // temperature at ADC = 280
#define TEMP360       390       // temperature at ADC = 360
#define TEMPCHP       30        // chip temperature while calibration
#define TIPMAX        8         // max number of tips
#define TIPNAMELENGTH 6         // max length of tip names (including termination)
#define TIPNAME       "BC1.5"   // default tip name

// Default timer values (0 = disabled)
#define TIME2SLEEP     5        // time to enter sleep mode in minutes
#define TIME2OFF      15        // time to shut off heater in minutes
#define TIMEOFBOOST   40        // time to stay in boost mode in seconds

// Control values
#define TIME2SETTLE   950       // time in microseconds to allow OpAmp output to settle
#define SMOOTHIE      0.05      // OpAmp output smooth factor (1=no smoothing; 0.05 default)
#define PID_ENABLE    true      // enable PID control
#define BEEP_ENABLE   true      // enable/disable buzzer
#define MAINSCREEN    1         // type of main screen (0: big numbers; 1: more infos)

// EEPROM identifier
#define EEPROM_IDENT   0x081F   // to identify if EEPROM was written by this program

//Beep
#define SetBeepCoolTime 200
unsigned long BeepCoolTime;

// Define the aggressive and conservative PID tuning parameters
double aggKp = 11, aggKi = 0.5, aggKd = 1;
double consKp = 11, consKi = 3, consKd = 5;

// Default values that can be changed by the user and stored in the EEPROM
uint16_t  DefaultTemp = TEMP_DEFAULT;
uint16_t  SleepTemp   = TEMP_SLEEP;
uint8_t   BoostTemp   = TEMP_BOOST;
uint8_t   time2sleep  = TIME2SLEEP;
uint8_t   time2off    = TIME2OFF;
uint8_t   timeOfBoost = TIMEOFBOOST;
uint8_t   MainScrType = MAINSCREEN;
bool      PIDenable   = PID_ENABLE;
bool      beepEnable  = BEEP_ENABLE;
// Default values for tips
uint16_t  CalTemp[TIPMAX][4] = {TEMP200, TEMP280, TEMP360, TEMPCHP};
char      TipName[TIPMAX][TIPNAMELENGTH] = {TIPNAME};
uint8_t   CurrentTip   = 0;
uint8_t   NumberOfTips = 1;

// Menu items
/*
   这个可以选择进行界面美化
  const char *DeleteMessage[]    = { "Warning", "You cannot", "delete your", "last tip!" };
  const char *MaxTipMessage[]    = { "Warning", "You reached", "maximum number", "of tips!" };
*/
// Variables for pin change interrupt
volatile uint8_t  a0, b0, c0, d0;
volatile bool     ab0;
volatile int      count, countMin, countMax, countStep;
volatile bool     handleMoved;

// Variables for temperature control
uint16_t  SetTemp, ShowTemp, gap, Step;
double    Input, Output, Setpoint, RawTemp, CurrentTemp, ChipTemp;

// Variables for voltage readings
uint16_t  Vcc, Vin;

// State variables
bool      inSleepMode = false;
bool      inOffMode   = false;
bool      inBoostMode = false;
bool      inCalibMode = false;
bool      isWorky     = true;
bool      beepIfWorky = true;
bool      TipIsPresent = true;
bool      FlipState = false;
// Timing variables
uint32_t  sleepmillis;
uint32_t  boostmillis;
uint32_t  buttonmillis;
uint8_t   goneMinutes;
uint8_t   goneSeconds;
uint8_t   SensorCounter = 255;
//串口助手
int x, y, a, b;
//欠压报警
byte UnderVoltage = 0;
// Control variables
uint16_t  time2settle = 300;

//模拟数字滚轮 Numerical scrolling effect
int Value;
int LastValue[3];
float SlidingAnimationY[3];

//开机密码 BootPassword
int Password = 0;

//屏幕保护-主题：密集运算
byte Line[4];

//编码器旋转调整方向设定
bool RotaryD = false;
// Specify the links and initial PID tuning parameters
PID ctrl(&Input, &Output, &Setpoint, aggKp, aggKi, aggKd, REVERSE);



//LANG 语言支持
/*  0 - 中文 CHINESE
    1 - 英文 ENGLISH
    2 - 日语
*/
byte LANG = 0;
void Flip(bool Fmode) {
  arduboy.flipVertical(Fmode);
  arduboy.flipHorizontal(Fmode);
}
void setup() {
  arduboy.begin();
  arduboy.setFrameRate(30);

  //Serial.begin(115200);
  // set the pin modes
  pinMode(SENSOR_PIN,   INPUT);
  pinMode(VIN_PIN,      INPUT);
  pinMode(BUZZER_PIN,   OUTPUT);
  pinMode(CONTROL_PIN,  OUTPUT);
  pinMode(ROTARY_1_PIN, INPUT_PULLUP);
  pinMode(ROTARY_2_PIN, INPUT_PULLUP);
  pinMode(BUTTON_PIN,   INPUT_PULLUP);
  pinMode(SWITCH_PIN,   INPUT_PULLUP);

  analogWrite(CONTROL_PIN, 255);        // this shuts off the heater
  digitalWrite(BUZZER_PIN, LOW);        // must be LOW when buzzer not in use

  // setup ADC
  ADCSRA |= bit (ADPS0) | bit (ADPS1) | bit (ADPS2);  // set ADC prescaler to 128
  ADCSRA |= bit (ADIE);                 // enable ADC interrupt
  interrupts ();                        // enable global interrupts

  // setup pin change interrupt for rotary encoder
  PCMSK0 = bit (PCINT0);                // Configure pin change interrupt on Pin8
  PCICR  = bit (PCIE0);                 // Enable pin change interrupt
  PCIFR  = bit (PCIF0);                 // Clear interrupt flag


  // get default values from EEPROM
  getEEPROM();
  //设置屏幕反转状态
  Flip(FlipState);
  //初始化屏幕保护动画
  for (byte a = 0; a < 4; a++) Line[a] = 32 * a;
  //开机密码
  BootPassword();

  // read supply voltages in mV
  Vcc = getVCC(); Vin = getVIN();

  // read and set current iron temperature
  SetTemp  = DefaultTemp;
  RawTemp  = denoiseAnalog(SENSOR_PIN);
  ChipTemp = getChipTemp();
  calculateTemp();

  // turn on heater if iron temperature is well below setpoint
  if ((CurrentTemp + 20) < DefaultTemp) analogWrite(CONTROL_PIN, 0);

  // tell the PID to range between 0 and the full window size
  ctrl.SetOutputLimits(0, 255);

  // start PID
  ctrl.SetMode(AUTOMATIC);

  // set initial rotary encoder values
  a0 = PINB & 1; b0 = PIND >> 7 & 1; ab0 = (a0 == b0);
  setRotary(TEMP_MIN, TEMP_MAX, TEMP_STEP, DefaultTemp);

  // reset sleep timer
  sleepmillis = millis();

  // long beep for setup completion
  beep(); beep();


}


void loop() {
  //HelpMeSerialer();
  ROTARYCheck();      // check rotary encoder (temp/boost setting, enter setup menu)
  SLEEPCheck();       // check and activate/deactivate sleep modes
  SENSORCheck();      // reads temperature and vibration switch of the iron
  Thermostat();       // heater control
  MainScreen();       // updates the main page on the OLED
  //beep(0);
}




// check rotary encoder; set temperature, toggle boost mode, enter setup menu accordingly
void ROTARYCheck() {
  // set working temperature according to rotary encoder value
  SetTemp = getRotary();

  // check rotary encoder switch
  uint8_t c = digitalRead(BUTTON_PIN);
  if ( !c && c0 ) {
    beep();
    buttonmillis = millis();
    while ( (!digitalRead(BUTTON_PIN)) && ((millis() - buttonmillis) < 500) );
    if ((millis() - buttonmillis) >= 500) SetupScreen();
    else {
      inBoostMode = !inBoostMode;
      if (inBoostMode) boostmillis = millis();
      handleMoved = true;
    }
  }
  c0 = c;

  // check timer when in boost mode
  if (inBoostMode && timeOfBoost) {
    goneSeconds = (millis() - boostmillis) / 1000;
    if (goneSeconds >= timeOfBoost) {
      inBoostMode = false;              // stop boost mode
      beep();                           // beep if boost mode is over
      beepIfWorky = true;               // beep again when working temperature is reached
    }
  }
}


// check and activate/deactivate sleep modes
void SLEEPCheck() {
  if (handleMoved) {                    // if handle was moved
    if (inSleepMode) {                  // in sleep or off mode?
      if ((CurrentTemp + 20) < SetTemp) // if temp is well below setpoint
        analogWrite(CONTROL_PIN, 0);    // then start the heater right now
      beep();                           // beep on wake-up
      beepIfWorky = true;               // beep again when working temperature is reached
    }
    handleMoved = false;                // reset handleMoved flag
    inSleepMode = false;                // reset sleep flag
    inOffMode   = false;                // reset off flag
    sleepmillis = millis();             // reset sleep timer
  }

  // check time passed since the handle was moved
  goneMinutes = (millis() - sleepmillis) / 60000;
  if ( (!inSleepMode) && (time2sleep > 0) && (goneMinutes >= time2sleep) ) {
    inSleepMode = true;
    beep();
  }
  if ( (!inOffMode)   && (time2off   > 0) && (goneMinutes >= time2off  ) ) {
    inOffMode   = true;
    beep();
  }
}


// reads temperature, vibration switch and supply voltages
void SENSORCheck() {
  analogWrite(CONTROL_PIN, 255);              // shut off heater in order to measure temperature
  delayMicroseconds(time2settle);             // wait for voltage to settle

  uint16_t temp = denoiseAnalog(SENSOR_PIN);  // read ADC value for temperature
  uint8_t d = digitalRead(SWITCH_PIN);        // check handle vibration switch
  if (d != d0) {
    handleMoved = true;  // set flag if handle was moved
    d0 = d;
  }
  if (! SensorCounter--) Vin = getVIN();      // get Vin every now and then

  analogWrite(CONTROL_PIN, Output);           // turn on again heater

  RawTemp += (temp - RawTemp) * SMOOTHIE;     // stabilize ADC temperature reading
  calculateTemp();

  // stabilize displayed temperature when around setpoint
  if ((ShowTemp != Setpoint) || (abs(ShowTemp - CurrentTemp) > 5)) ShowTemp = CurrentTemp;
  if (abs(ShowTemp - Setpoint) <= 1) ShowTemp = Setpoint;
  // set state variable if temperature is in working range; beep if working temperature was just reached
  gap = abs(SetTemp - CurrentTemp);
  if (gap < 5) {
    if (!isWorky && beepIfWorky) beep();
    isWorky = true;
    beepIfWorky = false;
  }
  else isWorky = false;
  // checks if tip is present or currently inserted
  if (ShowTemp > 500) TipIsPresent = false;   // tip removed ?
  if (!TipIsPresent && (ShowTemp < 500)) {    // new tip inserted ?
    analogWrite(CONTROL_PIN, 255);            // shut off heater
    beep();                                   // beep for info
    TipIsPresent = true;                      // tip is present now
    ChangeTipScreen();                        // show tip selection screen
    updateEEPROM();                           // update setting in EEPROM
    handleMoved = true;                       // reset all timers
    RawTemp  = denoiseAnalog(SENSOR_PIN);     // restart temp smooth algorithm
    c0 = LOW;                                 // switch must be released
    setRotary(TEMP_MIN, TEMP_MAX, TEMP_STEP, SetTemp);  // reset rotary encoder
  }
}


// calculates real temperature value according to ADC reading and calibration values
void calculateTemp() {
  if      (RawTemp < 200) CurrentTemp = map (RawTemp,   0, 200,                     21, CalTemp[CurrentTip][0]);
  else if (RawTemp < 280) CurrentTemp = map (RawTemp, 200, 280, CalTemp[CurrentTip][0], CalTemp[CurrentTip][1]);
  else                    CurrentTemp = map (RawTemp, 280, 360, CalTemp[CurrentTip][1], CalTemp[CurrentTip][2]);
}


//调温
void Thermostat() {
  // define Setpoint acoording to current working mode
  if      (inOffMode)   Setpoint = 0;
  else if (inSleepMode) Setpoint = SleepTemp;
  else if (inBoostMode) Setpoint = SetTemp + BoostTemp;
  else                  Setpoint = SetTemp;

  // control the heater (PID or direct)
  gap = abs(Setpoint - CurrentTemp);
  if (PIDenable) {
    Input = CurrentTemp;
    if (gap < 30) ctrl.SetTunings(consKp, consKi, consKd);
    else ctrl.SetTunings(aggKp, aggKi, aggKd);
    ctrl.Compute();
  } else {
    // turn on heater if current temperature is below setpoint
    if ((CurrentTemp + 0.5) < Setpoint) Output = 0; else Output = 255;
  }
  analogWrite(CONTROL_PIN, Output);     // set heater PWM
}


// creates a short beep on the buzzer
void beep() {
  /*
    if (beepEnable) {
    if (BeepCoolTime + SetBeepCoolTime < millis()) {
      if (state) BeepCoolTime = millis();
      analogWrite(BUZZER_PIN, 0);
    }  else analogWrite(BUZZER_PIN, 127);
    } else analogWrite(BUZZER_PIN, 0);
  */
  //体谅一下，没内存了，只能用原始的办法驱动无源蜂鸣器，否则我也不想牺牲宝贵响应资源换内存
  if (beepEnable) {
    for (uint8_t i = 0; i < 255; i++) {
      digitalWrite(BUZZER_PIN, HIGH);
      delayMicroseconds(125);
      digitalWrite(BUZZER_PIN, LOW);
      delayMicroseconds(125);
    }
  }
}

//设置旋转编码器的起始值
// sets start values for rotary encoder
void setRotary(int rmin, int rmax, int rstep, int rvalue) {
  countMin  = rmin << ROTARY_TYPE;
  countMax  = rmax << ROTARY_TYPE;
  if (RotaryD) countStep = rstep; else countStep = -rstep;
  count     = rvalue << ROTARY_TYPE;
}


// reads current rotary encoder value
int getRotary() {
  return (count >> ROTARY_TYPE);
}


// reads user settings from EEPROM; if EEPROM values are invalid, write defaults
void getEEPROM() {
  uint16_t identifier = (EEPROM.read(0) << 8) | EEPROM.read(1);
  if (identifier == EEPROM_IDENT) {
    DefaultTemp = (EEPROM.read(2) << 8) | EEPROM.read(3);
    SleepTemp   = (EEPROM.read(4) << 8) | EEPROM.read(5);
    BoostTemp   =  EEPROM.read(6);
    time2sleep  =  EEPROM.read(7);
    time2off    =  EEPROM.read(8);
    timeOfBoost =  EEPROM.read(9);
    MainScrType =  EEPROM.read(10);
    PIDenable   =  EEPROM.read(11);
    beepEnable  =  EEPROM.read(12);
    CurrentTip  =  EEPROM.read(13);
    NumberOfTips = EEPROM.read(14);
    LANG = EEPROM.read(15);
    FlipState = EEPROM.read(16);
    UnderVoltage = EEPROM.read(17);
    Password = (EEPROM.read(18) << 8) | EEPROM.read(19);
    RotaryD = EEPROM.read(20);
    uint8_t i, j;
    uint16_t counter = 21;
    for (i = 0; i < NumberOfTips; i++) {
      for (j = 0; j < TIPNAMELENGTH; j++) {
        TipName[i][j] = EEPROM.read(counter++);
      }
      for (j = 0; j < 4; j++) {
        CalTemp[i][j]  = EEPROM.read(counter++) << 8;
        CalTemp[i][j] |= EEPROM.read(counter++);
      }
    }
  }
  else {
    EEPROM.update(0, EEPROM_IDENT >> 8); EEPROM.update(1, EEPROM_IDENT & 0xFF);
    updateEEPROM();
  }
}


// writes user settings to EEPROM using updade function to minimize write cycles
void updateEEPROM() {
  EEPROM.update( 2, DefaultTemp >> 8);
  EEPROM.update( 3, DefaultTemp & 0xFF);
  EEPROM.update( 4, SleepTemp >> 8);
  EEPROM.update( 5, SleepTemp & 0xFF);
  EEPROM.update( 6, BoostTemp);
  EEPROM.update( 7, time2sleep);
  EEPROM.update( 8, time2off);
  EEPROM.update( 9, timeOfBoost);
  EEPROM.update(10, MainScrType);
  EEPROM.update(11, PIDenable);
  EEPROM.update(12, beepEnable);
  EEPROM.update(13, CurrentTip);
  EEPROM.update(14, NumberOfTips);
  EEPROM.update(15, LANG);
  EEPROM.update(16, FlipState);
  EEPROM.update(17, UnderVoltage);
  EEPROM.update(18, Password >> 8);
  EEPROM.update(19, Password & 0xFF);
  EEPROM.update(20, RotaryD);
  uint8_t i, j;
  uint16_t counter = 21;
  for (i = 0; i < NumberOfTips; i++) {
    for (j = 0; j < TIPNAMELENGTH; j++) EEPROM.update(counter++, TipName[i][j]);
    for (j = 0; j < 4; j++) {
      EEPROM.update(counter++, CalTemp[i][j] >> 8);
      EEPROM.update(counter++, CalTemp[i][j] & 0xFF);
    }
  }
}
//此片段用于DEBUG
void HelpMeSerialer() {
  //串口助手
  if (Serial.available()) {
    char TmpChar = Serial.read();
    switch (TmpChar) {
      case 'x': x = Serial.parseInt();
      case 'y': y = Serial.parseInt();
      case 'a': a = Serial.parseInt();
      case 'b': b = Serial.parseInt();
    }
  }
  /*
    Serial.println(String("X ->") + x);
    Serial.println(String("Y ->") + y);
    Serial.println(String("A ->") + a);
    Serial.println(String("B ->") + b);
  */
}
// draws the main screen
void MainScreen() {
  if (!(arduboy.nextFrame())) //帧率锁
    return;
  //状态
  byte SysState;
  if (ShowTemp > 500) SysState = 0;
  else if (inOffMode) {
    SysState = 1;
    DrawIntensiveComputing();
  } else if (inSleepMode) SysState = 2;
  else if (inBoostMode) SysState = 3;
  else if (isWorky) SysState = 4;
  else if (Output < 180) SysState = 5;
  else SysState = 6;
  if (SysState != 1) {
    if (MainScrType) {
      //arduboy.invert(0);
      arduboy.clear();
      //详细信息页
      arduboy.fillRect(0, 0, 128, 64, 1); //白底
      arduboy.setTextSize(1);
      SetTextColor(0);
      //预设名
      arduboy.drawSlowXYBitmap(0, 0, Tag, 16, 16, 0);
      arduboy.setCursor(19, 4); arduboy.print(TipName[CurrentTip]);
      //显示状态
      arduboy.setCursor(53, 1);
      arduboy.setTextSize(2);
      switch (LANG) {
        case 0: arduboy.drawSlowXYBitmap(80, 1, S_table[SysState], 28, 14, 0); break;  //中文 Chinese
        default: //英文 English
          switch (SysState) {
            case 1: arduboy.print(F("OFF")); break;
            case 2: arduboy.print(F("SLEEP")); break;
            case 3: arduboy.print(F("BOOST")); break;
            case 4: arduboy.print(F("WORKY")); break;
            case 5: arduboy.print(F("HEAT")); break;
            case 6: arduboy.print(F("HOLD")); break;
            default: arduboy.print(F("ERROR")); break;
          } break;
      }
      arduboy.drawSlowXYBitmap(113, 1, C_table[SysState], 14, 14, 0);
      arduboy.setTextSize(1);
      //芯片
      //R1
      if (getChipTemp() > 80 && ((millis() * 4) / 1000) % 2) beep(); else arduboy.drawSlowXYBitmap(2, 18, Chip, 14, 14, 0);

      //R2
      if ((float)Vin / 100 < UnderVoltage && ((millis() * 4) / 1000) % 2) beep(); else arduboy.drawSlowXYBitmap(2, 34, Lightning, 14, 14, 0);
      //R3
      arduboy.setCursor(19, 16); arduboy.print(getChipTemp(), 1); arduboy.print((char)248); arduboy.print(F("C")); //芯片温度
      arduboy.setCursor(19, 24); arduboy.print((float)getVCC() / 1000, 2); arduboy.print(F("V")); //芯片电压
      arduboy.setCursor(19, 32); arduboy.print((float)Vin / 1000, 1); arduboy.print(F("V")); //输入电压
      arduboy.setCursor(19, 40); arduboy.print(F(VERSION)); //固件
      //显示探头温度
      DrawNumRect(ShowTemp);

      DrawStatusBar(0);
      arduboy.display();
    } else {
      //arduboy.invert(1);
      arduboy.setTextSize(6);
      SetTextColor(1);
      arduboy.clear();
      if (getChipTemp() > 80 && ((millis() * 4) / 1000) % 2) beep();
      if ((float)Vin / 100 < UnderVoltage && ((millis() * 4) / 1000) % 2) beep();
      arduboy.setCursor(12, 2);

      if (ShowTemp > 500) arduboy.print(999); else arduboy.print(ShowTemp);
      arduboy.fillRect(0, 48, 128, 16, 1);

      DrawStatusBar(0);
      arduboy.display();
    }
  }
}
void DrawNumRect(int n) {
  arduboy.setCursor(57, 18);
  arduboy.setTextSize(4);
  if (ShowTemp > 500) arduboy.print(F("000")); else arduboy.print(n);
  arduboy.drawRect(55, 16, 72, 32, 0);
}
void DrawStatusBar(bool color) {
  SetTextColor(color);
  arduboy.setTextSize(1);
  //温度条
  //框
  arduboy.drawRect(1, 49, 102, 14, color);
  //条
  if (ShowTemp <= 500) arduboy.fillRect(1, 49, map(ShowTemp, 0, 500, 2, 102), 14, color);
  //指示部分
  arduboy.fillRect(map(Setpoint, 0, 500, 2, 102) - 2, 50, 3, 13, color);
  //先来个白底
  arduboy.fillRect(map(Setpoint, 0, 500, 2, 102) - 3, 60, 5, 4, color);
  arduboy.drawLine(map(Setpoint, 0, 500, 2, 102) - 1, 60, map(Setpoint, 0, 500, 2, 102) - 1, 49, !color);

  //画指示针
  arduboy.drawSlowXYBitmap(map(Setpoint, 0, 500, 2, 102) - 3, 59, Pointer, 5, 4, !color);

  //功率条
  arduboy.drawRect(104, 49, 23, 14, color);
  arduboy.fillRect(104, 49, map(Output, 255, 0, 0, 23), 14, color);

  SetTextColor(!color);
  //////////////进入反色////////////////////////////////
  arduboy.setCursor(2, 55); arduboy.print(Setpoint, 0); arduboy.print((char)248); arduboy.print(F("C")); //探头预设温度
  arduboy.setCursor(105, 55); arduboy.print(map(Output, 255, 0, 0, 100)); arduboy.print(F("%")); //功率百分比
  SetTextColor(color);
}

//设置画笔颜色
void SetTextColor(bool color) {
  arduboy.setTextBackground(!color);
  arduboy.setTextColor(color);
}
// setup screen
void SetupScreen() {
  analogWrite(CONTROL_PIN, 255);      // shut off heater
  beep();
  uint16_t SaveSetTemp = SetTemp;
  uint8_t selection = 0;
  bool repeat = true;

  while (repeat) {
    //arduboy.invert(0);
    MenuLevel = 0; //默认打开主菜单
    selection = MenuScreen(selection);
    switch (selection) {
      case 0:   MenuLevel = 1; TipScreen();  repeat = false; break;
      case 1:   MenuLevel = 2; TempScreen();  break;
      case 2:   MenuLevel = 3; TimerScreen();  break;
      case 3:   MenuLevel = 4; PIDenable = MenuScreen(PIDenable); break;
      case 4:   ScreenSet(); break;
      case 5:   MenuLevel = 6; beepEnable = MenuScreen(beepEnable); break;
      case 6:   RotarySet(); break;
      case 7:   UnderVoltageSet(); break;
      case 8:   PasswordSet(); break;
      case 9:   MenuLevel = 8; LANG = MenuScreen(LANG); break;
      case 10:   QRcodeScreen(); break;
      default:  repeat = false; break;
    }
  }
  updateEEPROM();
  handleMoved = true;
  SetTemp = SaveSetTemp;
  setRotary(TEMP_MIN, TEMP_MAX, TEMP_STEP, SetTemp);
}

void RotarySet() {
  bool Exit = false;
  float rad;
  byte ExitBar = 0;
  SetTextColor(0);
  lastbutton = (!digitalRead(BUTTON_PIN));
  setRotary(60, 420, 18, 240);
  do {
    arduboy.setTextSize(1);
    Setpoint = getRotary();
    ShowTemp = Setpoint;


    arduboy.clear();
    //仪表盘
    arduboy.fillRect(0, 0, 128, 64, 1);
    arduboy.fillTriangle(24 + 24 * cos(rad), 24 - 24 * sin(rad), 24 + 3 * sin(rad), 24 + 3 * cos(rad), 24 - 3 * sin(rad), 24 - 3 * cos(rad), 0);
    arduboy.drawCircle(24, 24, 22, 0);
    arduboy.drawCircle(24, 24, 19, 0);
    arduboy.drawCircle(24, 24, 3, 0);
    //右上角的模式提示文本
    arduboy.setCursor(55, 1);
    arduboy.setTextSize(2);
    arduboy.print(F("MODE "));
    if (RotaryD) {
      arduboy.print(F("-"));
      rad = ((Setpoint - 60) / 360.0) * (2 * PI) - PI / 2;
    } else {
      arduboy.print(F("+"));
      rad = ((-Setpoint - 60) / 360.0) * (2 * PI) + PI * 1 / 6;
    }
    //右侧数字显示
    DrawNumRect(ShowTemp);
    //下端的状态条
    DrawStatusBar(0);
    //退出条
    arduboy.fillRect(0, 0, ExitBar, 4, 0);

    arduboy.display();


    CheckLastButton();
    if (!digitalRead(BUTTON_PIN) && !lastbutton) {

      ExitBar += 8;
      if (ExitBar > 127) Exit = true;
    } else {
      if (ExitBar > 1 && ExitBar < 64) {
        RotaryD = !RotaryD;
        setRotary(60, 420, 18, 240);
      }
      ExitBar = 0;
    }

  } while (!Exit);

}
//显示设置菜单
// tip settings screen
void ScreenSet() {
  uint8_t selection = 0;
  bool repeat = true;
  while (repeat) {
    MenuLevel = 9;
    selection = MenuScreen(selection);
    switch (selection) {
      case 0:   MenuLevel = 5; MainScrType = MenuScreen(MainScrType);   break;
      case 1:   FlipState = !FlipState; break;
      default:  repeat = false;      break;
    }
    Flip(FlipState); //设置屏幕反转状态
  }
  updateEEPROM();
}

//预设设置菜单
// tip settings screen
void TipScreen() {
  uint8_t selection = 0;
  bool repeat = true;
  while (repeat) {
    MenuLevel = 1;
    selection = MenuScreen(selection);
    switch (selection) {
      case 0:   ChangeTipScreen();   break;
      case 1:   CalibrationScreen(); break;
      case 2:   InputNameScreen();   break;
      case 3:   DeleteTipScreen();   break;
      case 4:   AddTipScreen();      break;
      default:  repeat = false;      break;
    }
  }
}

//温控设置菜单
// temperature settings screen
void TempScreen() {
  uint8_t selection = 0;
  bool repeat = true;
  while (repeat) {
    selection = MenuScreen(selection);
    switch (selection) {
      case 0:   setRotary(TEMP_MIN, TEMP_MAX, TEMP_STEP, DefaultTemp);
        DefaultTemp = InputScreen(18); break;
      case 1:   setRotary(20, 200, TEMP_STEP, SleepTemp);
        SleepTemp = InputScreen(19); break;
      case 2:   setRotary(10, 100, TEMP_STEP, BoostTemp);
        BoostTemp = InputScreen(20); break;
      default:  repeat = false; break;
    }
  }
  updateEEPROM();
}

//定时器设置菜单
// timer settings screen
void TimerScreen() {
  uint8_t selection = 0;
  bool repeat = true;
  while (repeat) {
    selection = MenuScreen(selection);
    switch (selection) {
      case 0:   setRotary(0, 30, 1, time2sleep);
        time2sleep = InputScreen(22); break;
      case 1:   setRotary(0, 60, 5, time2off);
        time2off = InputScreen(23); break;
      case 2:   setRotary(0, 180, 10, timeOfBoost);
        timeOfBoost = InputScreen(24); break;
      default:  repeat = false; break;
    }
  }
  updateEEPROM();
}
//英语支持
void Print_EN(byte i) {
  char buffer[11];
  strcpy_P(buffer, (char *)pgm_read_word(&(EN_table[i])));
  arduboy.print(buffer);
}
//菜单界面
// menu screen
uint8_t MenuScreen(uint8_t selected) {
  int SlidingAnimationX;
  uint8_t lastselected = selected;
  setRotary(0, Menu_table[MenuLevel] - 1, 1, selected);
  lastbutton = (!digitalRead(BUTTON_PIN));
  SetTextColor(1);
  do {
    selected = getRotary();
    //非线性滑动动画
    SlidingAnimationX += (selected - lastselected) * 56;
    if (SlidingAnimationX != 0) SlidingAnimationX += 0.6 * (-SlidingAnimationX);
    lastselected = selected;
    arduboy.clear();
    //绘制图标 如果有指定的话
    for (byte i = 0; i < 5; i++) if (selected - 2 + i >= 0 && selected - 2 + i < Menu_table[MenuLevel]) DrawApp(-72 + i * 56 + SlidingAnimationX, selected - 2 + i + QueryMenuObject());
    DrawAppText(selected + QueryMenuObject());

    arduboy.display();
    CheckLastButton();
    //beep(0);
  } while (digitalRead(BUTTON_PIN) || lastbutton);
  beep();
  return selected;
}
//显示APP图标
void DrawApp(int x, byte appID) {
  DrawUIFrame(x, 0, 1);
  drawSlowXYBitmapResize(x + 3, 3, Ico_table[appID], 14, 14, 3, 1);
}
//显示APP对应的文本
void DrawAppText(byte appID) {
  //  arduboy.setCursor(0, 55); arduboy.print(appID);
  if (LANG == 0) arduboy.drawSlowXYBitmap(48, 48, CN_table[appID], 36, 16, 1); else if (LANG == 2) {
    drawText(48, 52, JP_table[appID], pgm_read_byte(&(JP_Length_table[appID])));
  } else {
    arduboy.setCursor(48, 52);
    arduboy.setTextSize(1);
    Print_EN(appID);
  }
}
void DrawUIFrame(int x, int y, bool color) {
  arduboy.fillRect(x, y, 48, 48, color);
  arduboy.fillRect(x + 3, y + 3, 42, 42, !color); //雕空
  DrawPoint(x, y, 0);
  DrawPoint(x + 47, y, 0);
  DrawPoint(x, y + 47, 0);
  DrawPoint(x + 47, y + 47, 0);
}
void DrawPoint(int x, int y, bool color) {
  arduboy.drawPixel(x + 1, y, color);
  arduboy.drawPixel(x - 1, y, color);
  arduboy.drawPixel(x, y + 1, color);
  arduboy.drawPixel(x, y - 1, color);
  arduboy.drawPixel(x, y, color);
}
//检查按键
void CheckLastButton() {
  if (lastbutton && digitalRead(BUTTON_PIN)) {
    delay(10);
    lastbutton = false;
  }
}
//返回对应层数的对象数
byte QueryMenuObject() {
  int SUM = 0;
  for (int i = 0; i < (MenuLevel); i++) SUM += Menu_table[i];
  return SUM;
}
//信息窗
/*
  void MessageScreen(const char *Items[], uint8_t numberOfItems) {
  lastbutton = (!digitalRead(BUTTON_PIN));

  //u8g.setFont(//u8g_font_9x15);
  //u8g.setFontPosTop();
  for (uint8_t i = 0; i < numberOfItems; i++) //u8g.drawStr( 0, i * 16,  Items[i]);

    do {
      CheckLastButton();
    } while (digitalRead(BUTTON_PIN) || lastbutton);
  beep();
  }
*/
/*
   好看是好看，但是浪费内存
  int wav(byte wavi, int num) {
  return (wavi + byte(millis() / 100)) * (float(float(num - countMin) / float(countMax - countMin)) - 0.5) * 5;
  }
*/
//FP 密集运算屏保
void DrawIntensiveComputing() {
  analogWrite(CONTROL_PIN, 255); //关闭MOS管
  float calculate;
  // while (1) {
  arduboy.clear();

  //随机线条
  DrawIntensiveComputingLine();

  calculate = sin(millis() / 4000.0);
  //模拟噪点
  for (int i = 0; i < calculate * 256 + 256; i++)  arduboy.drawPixel(random(0, 128), random(0, 64), 1);
  //声效
  if ((beepEnable)) analogWrite(BUZZER_PIN, 64 + calculate * 64 + random(-8, 8));
  //if ((beepEnable)) tone(BUZZER_PIN, int(calculate * 300) + 500 + random(-50, 50));  //没必要浪费内存

  arduboy.display();
  //delay(60-calculate*30);
  //}
}
//绘制屏保-密集运算线条
void DrawIntensiveComputingLine() {
  for (byte a = 0; a < 4; a++) {
    Line[a] += random(-1, 1);
    if (Line[a] > 128) Line[a] -= 128;
    for (byte b = 0; b < random(3, 6); b++) {
      arduboy.drawFastHLine(0, Line[a] + random(-10, 10), 128, 1); //水平线
      arduboy.drawFastVLine(Line[a] + random(-10, 10), 0, 64, 1); //垂直线
    }
  }
}
//模拟数字滚轮 Numerical scrolling effect
void DisplayNum(int Num) {
  arduboy.setTextSize(6);
  SetTextColor(0);
  //数字滚轮
  for (byte i = 0; i < 3; i++) LastValue[i] = int(Value / pow(10, 2 - i)) % 10;
  Value = Num;
  for (byte i = 0; i < 3; i++) {
    SlidingAnimationY[i] += ((int(Value / pow(10, 2 - i)) % 10) - LastValue[i]) * 50;
    if (SlidingAnimationY[i] != 0) SlidingAnimationY[i] += 0.8 * (-SlidingAnimationY[i]);
    arduboy.fillRect(0 + i * 44, 0, 38, 50, 1); //白底
    for (int ii = -1; ii < 2; ii++) {
      arduboy.setCursor(4 + i * 44, 4 - SlidingAnimationY[i] + ii * 50);
      arduboy.print(LastValue[i] + ii);
    }
  }
  //刻度标
  arduboy.fillRect(0, 0, 128, 2, 0); //上遮罩层
  arduboy.fillRect(0, 48, 128, 16, 0); //下遮罩层
}

//数值输入界面
// input value screen
uint16_t InputScreen(byte appID) {
  lastbutton = (!digitalRead(BUTTON_PIN));
  do {
    arduboy.clear();
    DisplayNum(getRotary());
    DrawAppText(appID);
    arduboy.display();
    CheckLastButton();
  } while (digitalRead(BUTTON_PIN) || lastbutton);
  beep();
  return Value;
}
int InputBigNum(int InputPW, byte appID) {
  setRotary(0, 900, 100, InputPW);
  InputPW = InputScreen(appID);
  setRotary(InputPW, InputPW + 90, 10, InputPW);
  InputPW = InputScreen(appID);
  setRotary(InputPW, InputPW + 9, 1, InputPW);
  InputPW = InputScreen(appID);
  return InputPW;
}
void QRcodeScreen() {
  arduboy.clear();
  arduboy.drawSlowXYBitmap(40, 0, QRCode, 48, 48, 1);
  arduboy.display();
  delay(100);
  do {
  } while (digitalRead(BUTTON_PIN) || lastbutton);
  beep();
}
//欠压报警设置
// information display screen
void UnderVoltageSet() {
  setRotary(0, 250, 1, UnderVoltage);
  UnderVoltage = InputScreen(7);
  beep();
}
//设置开机密码
void PasswordSet() {
  Password = InputBigNum(Password, 8);
  beep();
}

void BootPassword() {
  if (Password != 0) {
    do {
      arduboy.clear();
      DrawApp(40, 8);
      DrawAppText(8);
      arduboy.display();
      delay(1000);
      beep(); beep(); beep();
    } while (InputBigNum(0, 8) != Password);
  }
}
//更换预设界面
// change tip screen
void ChangeTipScreen() {
  uint8_t selected = CurrentTip;
  uint8_t lastselected = selected;
  int8_t  arrow = 0;
  if (selected) arrow = 1;
  setRotary(0, NumberOfTips - 1, 1, selected);
  lastbutton = (!digitalRead(BUTTON_PIN));
  do {
    //beep(0);
    arduboy.clear();
    selected = getRotary();
    arrow = constrain(arrow + selected - lastselected, 0, 2);
    lastselected = selected;
    SetTextColor(0);
    arduboy.setTextSize(2);
    arduboy.setCursor(0, 0); arduboy.print(F("Select Tip"));
    SetTextColor(1);
    arduboy.setCursor(0, 16 * (arrow + 1)); arduboy.print(F(">"));
    for (uint8_t i = 0; i < 3; i++) {
      uint8_t drawnumber = selected + i - arrow;
      if (drawnumber < NumberOfTips) {
        arduboy.setCursor(12, 16 * (i + 1)); arduboy.print(TipName[selected + i - arrow]);
      }
    }
    CheckLastButton();
    arduboy.display();
  } while (digitalRead(BUTTON_PIN) || lastbutton);

  beep();
  CurrentTip = selected;
}

//温度校准界面
// temperature calibration screen
void CalibrationScreen() {
  uint16_t CalTempNew[4];
  for (uint8_t CalStep = 0; CalStep < 3; CalStep++) {
    SetTemp = CalTemp[CurrentTip][CalStep];
    setRotary(100, 500, 1, SetTemp);
    beepIfWorky = true;
    lastbutton = (!digitalRead(BUTTON_PIN));
    do {
      arduboy.clear();
      arduboy.setTextSize(2);
      SENSORCheck();      // reads temperature and vibration switch of the iron
      Thermostat();       // heater control
      arduboy.setCursor(0, 0); arduboy.print(F("Step: ")); arduboy.print(CalStep + 1); arduboy.print("/3");
      if (isWorky) {
        arduboy.setCursor(0, 16); arduboy.print(F("Set measured"));
        arduboy.setCursor(0, 32); arduboy.print(F("temp: ")); arduboy.print(getRotary());
      } else {
        arduboy.setCursor(0, 16); arduboy.print(F("ADC: ")); arduboy.print(uint16_t(RawTemp));
        arduboy.setCursor(0, 32); arduboy.print(F("Please wait"));
      }
      CheckLastButton();
      arduboy.display();
    } while (digitalRead(BUTTON_PIN) || lastbutton);

    CalTempNew[CalStep] = getRotary();
    beep(); delay (10);
  }

  analogWrite(CONTROL_PIN, 255);              // shut off heater
  delayMicroseconds(time2settle);             // wait for voltage to settle
  CalTempNew[3] = getChipTemp();              // read chip temperature
  if ((CalTempNew[0] + 30 < CalTempNew[1]) && (CalTempNew[1] + 30 < CalTempNew[2])) {
    MenuLevel = 7;
    if (MenuScreen(0)) {
      for (uint8_t i = 0; i < 4; i++) CalTemp[CurrentTip][i] = CalTempNew[i];
    }
  }
}

//命名界面 文本输入界面
// input tip name screen
void InputNameScreen() {
  uint8_t  value;
  for (uint8_t digit = 0; digit < (TIPNAMELENGTH - 1); digit++) {
    lastbutton = (!digitalRead(BUTTON_PIN));
    setRotary(31, 96, 1, 65);
    do {
      value = getRotary();
      if (value == 31) {
        value = 95;
        setRotary(31, 96, 1, 95);
      }
      if (value == 96) {
        value = 32;
        setRotary(31, 96, 1, 32);
      }
      //arduboy.setCursor(0, 0);arduboy.print();
      arduboy.clear();
      arduboy.setTextSize(2);
      arduboy.setCursor(16 * digit, 48); arduboy.print(char(94));
      arduboy.setCursor(0, 32);
      for (uint8_t i = 0; i < digit; i++) arduboy.print(TipName[CurrentTip][i]);
      arduboy.setCursor(16 * digit, 32); arduboy.print(char(value));
      CheckLastButton();
      arduboy.display();
    } while (digitalRead(BUTTON_PIN) || lastbutton);
    TipName[CurrentTip][digit] = value;
    beep(); delay (10);
  }
  TipName[CurrentTip][TIPNAMELENGTH - 1] = 0;
  return value;
}


// delete tip screen
void DeleteTipScreen() {
  MenuLevel = 7;
  if (NumberOfTips == 1) {
    //MessageScreen(DeleteMessage, sizeof(DeleteMessage));
  }
  else if (MenuScreen(0)) {
    if (CurrentTip == (NumberOfTips - 1)) {
      CurrentTip--;
    }
    else {
      for (uint8_t i = CurrentTip; i < (NumberOfTips - 1); i++) {
        for (uint8_t j = 0; j < TIPNAMELENGTH; j++) TipName[i][j] = TipName[i + 1][j];
        for (uint8_t j = 0; j < 4; j++)             CalTemp[i][j] = CalTemp[i + 1][j];
      }
    }
    NumberOfTips--;
  }
}


// add new tip screen
void AddTipScreen() {
  if (NumberOfTips < TIPMAX) {
    CurrentTip = NumberOfTips++; InputNameScreen();
    CalTemp[CurrentTip][0] = TEMP200; CalTemp[CurrentTip][1] = TEMP280;
    CalTemp[CurrentTip][2] = TEMP360; CalTemp[CurrentTip][3] = TEMPCHP;
  } //MessageScreen(MaxTipMessage, sizeof(MaxTipMessage)); 信息窗
}


// average several ADC readings in sleep mode to denoise
uint16_t denoiseAnalog (byte port) {
  uint16_t result = 0;
  ADCSRA |= bit (ADEN) | bit (ADIF);    // enable ADC, turn off any pending interrupt
  if (port >= A0) port -= A0;           // set port and
  ADMUX = (0x0F & port) | bit(REFS0);   // reference to AVcc
  set_sleep_mode (SLEEP_MODE_ADC);      // sleep during sample for noise reduction
  for (uint8_t i = 0; i < 32; i++) {    // get 32 readings
    sleep_mode();                       // go to sleep while taking ADC sample
    while (bitRead(ADCSRA, ADSC));      // make sure sampling is completed
    result += ADC;                      // add them up
  }
  bitClear (ADCSRA, ADEN);              // disable ADC
  return (result >> 5);                 // devide by 32 and return value
}

/*
  //读取芯片温度
  // get internal temperature by reading ADC channel 8 against 1.1V reference
  double getChipTemp() {
  unsigned int wADC;
  double t;
  ADMUX = (_BV(REFS1) | _BV(REFS0) | _BV(MUX3));
  ADCSRA |= _BV(ADEN);
  delay(5);
  ADCSRA |= _BV(ADSC);
  while (bit_is_set(ADCSRA, ADSC));
  wADC = ADCW;
  t = (wADC - ChipTempCalVal ) / 1.22;
  return (t);
  }
*/
// get internal temperature by reading ADC channel 8 against 1.1V reference
double getChipTemp() {
  uint16_t result = 0;
  ADCSRA |= bit (ADEN) | bit (ADIF);    // enable ADC, turn off any pending interrupt
  ADMUX = bit (REFS1) | bit (REFS0) | bit (MUX3); // set reference and mux
  delay(10);                            // wait for voltages to settle
  set_sleep_mode (SLEEP_MODE_ADC);      // sleep during sample for noise reduction
  for (uint8_t i = 0; i < 32; i++) {    // get 32 readings
    sleep_mode();                       // go to sleep while taking ADC sample
    while (bitRead(ADCSRA, ADSC));      // make sure sampling is completed
    result += ADC;                      // add them up
  }
  bitClear (ADCSRA, ADEN);              // disable ADC
  result >>= 2;                         // devide by 4
  return ((result - 2594) / 9.76);      // calculate internal temperature in degrees C
}

// get input voltage in mV by reading 1.1V reference against AVcc
uint16_t getVCC() {
  uint16_t result = 0;
  ADCSRA |= bit (ADEN) | bit (ADIF);    // enable ADC, turn off any pending interrupt
  // set Vcc measurement against 1.1V reference
  ADMUX = bit (REFS0) | bit (MUX3) | bit (MUX2) | bit (MUX1);
  delay(1);                             // wait for voltages to settle
  set_sleep_mode (SLEEP_MODE_ADC);      // sleep during sample for noise reduction
  for (uint8_t i = 0; i < 16; i++) {    // get 16 readings
    sleep_mode();                       // go to sleep while taking ADC sample
    while (bitRead(ADCSRA, ADSC));      // make sure sampling is completed
    result += ADC;                      // add them up
  }
  bitClear (ADCSRA, ADEN);              // disable ADC
  result >>= 4;                         // devide by 16
  return (1125300L / result);           // 1125300 = 1.1 * 1023 * 1000
}


// get supply voltage in mV
uint16_t getVIN() {
  long result;
  result = denoiseAnalog (VIN_PIN);     // read supply voltage via voltage divider
  return (result * Vcc / 179.474);      // 179.474 = 1023 * R13 / (R12 + R13)
}

//ADC中断服务
// ADC interrupt service routine
EMPTY_INTERRUPT (ADC_vect);             // nothing to be done here

//旋转编码器触发中断
// Pin change interrupt service routine for rotary encoder
ISR (PCINT0_vect) {
  uint8_t a = PINB & 1;
  uint8_t b = PIND >> 7 & 1;
  if (a != a0) {              // A changed
    a0 = a;
    if (b != b0) {            // B changed
      b0 = b;
      count = constrain(count + ((a == b) ? countStep : -countStep), countMin, countMax);
      if (ROTARY_TYPE && ((a == b) != ab0)) {
        count = constrain(count + ((a == b) ? countStep : -countStep), countMin, countMax);;
      }
      ab0 = (a == b);
      handleMoved = true;
    }
  }
}

//显示位图，并允许放大 代码片段改自arduboy2
void drawSlowXYBitmapResize(int x, int y, const uint8_t *bitmap, uint8_t w, uint8_t h, uint8_t size, uint8_t color) {
  // no need to draw at all of we're offscreen
  /*
    if (x + w < 0 || x > WIDTH - 1 || y + h < 0 || y > HEIGHT - 1)
    return;
  */
  int16_t xi, yi, byteWidth = (w + 7) / 8;
  for (yi = 0; yi < h; yi ++) {
    for (xi = 0; xi < w; xi ++) {
      if (pgm_read_byte(bitmap + yi * byteWidth + xi / 8) & (128 >> (xi & 7))) {
        //arduboy.drawPixel(x + xi, y + yi, color);
        arduboy.fillRect(x + xi * size, y + yi * size, size, size, color);
      }
    }
  }
}
/*
  8x8 dot Japanese font for Arduboy

  Copyright (c) 2016 emutyworks

  Released under the MIT license
  https://github.com/emutyworks/8x8DotJPFont/blob/master/LICENSE.txt
*/
void drawText(uint8_t x, uint8_t y, const uint8_t *mes, uint8_t cnt)
{
  uint8_t pb;
  uint8_t page;
  uint8_t screen_start = 0;
  uint8_t screen_end = 128;

  if (x < screen_start) {
    x = screen_start;
  }

  for (uint8_t i = 0; i < cnt; i++) {
    pb = pgm_read_byte_near(mes + i);

    switch (pb) {
      case MISAKI_FONT_F0_PAGE:
        page = MISAKI_FONT_F0_PAGE;
        continue;
      case MISAKI_FONT_F1_PAGE:
        page = MISAKI_FONT_F1_PAGE;
        continue;
      case MISAKI_FONT_F2_PAGE:
        page = MISAKI_FONT_F2_PAGE;
        continue;
    }

    if (!page) {
      continue;
    }

    switch (page) {
#ifdef MISAKI_FONT_F0_H
      case MISAKI_FONT_F0_PAGE:
        if (pb > MISAKI_FONT_F0_SIZE) {
          continue;
        }
        if ((x + 8) > screen_end) {
          x = screen_start;
          y = y + 8;
        }
        arduboy.drawBitmap(x, y,  misaki_font_f0[ pb ], MISAKI_FONT_F0_W, 8, WHITE);
        x = x + 8;
        break;
#endif
#ifdef MISAKI_FONT_F1_H
      case MISAKI_FONT_F1_PAGE:
        if (pb > MISAKI_FONT_F1_SIZE) {
          continue;
        }
        if ((x + 4) > screen_end) {
          x = screen_start;
          y = y + 8;
        }
        arduboy.drawBitmap(x, y,  misaki_font_f1[ pb ], MISAKI_FONT_F1_W, 8, WHITE);
        arduboy.drawBitmap(x + 3, y, misaki_font_0x00, 1, 8, WHITE);
        x = x + 4;
        break;
#endif
#ifdef MISAKI_FONT_F2_H
      case MISAKI_FONT_F2_PAGE:
        if (pb > MISAKI_FONT_F2_SIZE) {
          continue;
        }
        if ((x + 8) > screen_end) {
          x = screen_start;
          y = y + 8;
        }
        arduboy.drawBitmap(x, y,  misaki_font_f2[ pb ], MISAKI_FONT_F2_W, 8, WHITE);
        arduboy.drawBitmap(x + 7, y, misaki_font_0x00, 1, 8, WHITE);
        x = x + 8;
        break;
#endif
    }
  }
}
